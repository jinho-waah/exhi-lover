{"ast":null,"code":"import _objectSpread from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classPrivateFieldInitSpec from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\n\nvar _mutations, _mutationId;\n\n// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = (_mutations = /*#__PURE__*/new WeakMap(), _mutationId = /*#__PURE__*/new WeakMap(), /*#__PURE__*/function (_Subscribable) {\n  _inherits(MutationCache, _Subscribable);\n\n  var _super = _createSuper(MutationCache);\n\n  function MutationCache() {\n    var _this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MutationCache);\n\n    _this = _super.call(this);\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _mutations, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _mutationId, {\n      writable: true,\n      value: void 0\n    });\n\n    _this.config = config;\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _mutations, /* @__PURE__ */new Map());\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _mutationId, Date.now());\n\n    return _this;\n  }\n\n  _createClass(MutationCache, [{\n    key: \"build\",\n    value: function build(client, options, state) {\n      var _this$mutationId;\n\n      var mutation = new Mutation({\n        mutationCache: this,\n        mutationId: _classPrivateFieldSet(this, _mutationId, (_this$mutationId = _classPrivateFieldGet(this, _mutationId), ++_this$mutationId)),\n        options: client.defaultMutationOptions(options),\n        state: state\n      });\n      this.add(mutation);\n      return mutation;\n    }\n  }, {\n    key: \"add\",\n    value: function add(mutation) {\n      var _classPrivateFieldGet2;\n\n      var scope = scopeFor(mutation);\n      var mutations = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _mutations).get(scope)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : [];\n      mutations.push(mutation);\n\n      _classPrivateFieldGet(this, _mutations).set(scope, mutations);\n\n      this.notify({\n        type: \"added\",\n        mutation: mutation\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(mutation) {\n      var scope = scopeFor(mutation);\n\n      if (_classPrivateFieldGet(this, _mutations).has(scope)) {\n        var _classPrivateFieldGet3;\n\n        var mutations = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _mutations).get(scope)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.filter(function (x) {\n          return x !== mutation;\n        });\n\n        if (mutations) {\n          if (mutations.length === 0) {\n            _classPrivateFieldGet(this, _mutations).delete(scope);\n          } else {\n            _classPrivateFieldGet(this, _mutations).set(scope, mutations);\n          }\n        }\n      }\n\n      this.notify({\n        type: \"removed\",\n        mutation: mutation\n      });\n    }\n  }, {\n    key: \"canRun\",\n    value: function canRun(mutation) {\n      var _classPrivateFieldGet4;\n\n      var firstPendingMutation = (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _mutations).get(scopeFor(mutation))) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.find(function (m) {\n        return m.state.status === \"pending\";\n      });\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    }\n  }, {\n    key: \"runNext\",\n    value: function runNext(mutation) {\n      var _classPrivateFieldGet5, _foundMutation$contin;\n\n      var foundMutation = (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _mutations).get(scopeFor(mutation))) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.find(function (m) {\n        return m !== mutation && m.state.isPaused;\n      });\n      return (_foundMutation$contin = foundMutation === null || foundMutation === void 0 ? void 0 : foundMutation.continue()) !== null && _foundMutation$contin !== void 0 ? _foundMutation$contin : Promise.resolve();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n\n      notifyManager.batch(function () {\n        _this2.getAll().forEach(function (mutation) {\n          _this2.remove(mutation);\n        });\n      });\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return _toConsumableArray(_classPrivateFieldGet(this, _mutations).values()).flat();\n    }\n  }, {\n    key: \"find\",\n    value: function find(filters) {\n      var defaultedFilters = _objectSpread({\n        exact: true\n      }, filters);\n\n      return this.getAll().find(function (mutation) {\n        return matchMutation(defaultedFilters, mutation);\n      });\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll() {\n      var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.getAll().filter(function (mutation) {\n        return matchMutation(filters, mutation);\n      });\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(event) {\n      var _this3 = this;\n\n      notifyManager.batch(function () {\n        _this3.listeners.forEach(function (listener) {\n          listener(event);\n        });\n      });\n    }\n  }, {\n    key: \"resumePausedMutations\",\n    value: function resumePausedMutations() {\n      var pausedMutations = this.getAll().filter(function (x) {\n        return x.state.isPaused;\n      });\n      return notifyManager.batch(function () {\n        return Promise.all(pausedMutations.map(function (mutation) {\n          return mutation.continue().catch(noop);\n        }));\n      });\n    }\n  }]);\n\n  return MutationCache;\n}(Subscribable));\n\nfunction scopeFor(mutation) {\n  var _mutation$options$sco, _mutation$options$sco2;\n\n  return (_mutation$options$sco = (_mutation$options$sco2 = mutation.options.scope) === null || _mutation$options$sco2 === void 0 ? void 0 : _mutation$options$sco2.id) !== null && _mutation$options$sco !== void 0 ? _mutation$options$sco : String(mutation.mutationId);\n}\n\nexport { MutationCache };","map":{"version":3,"mappings":"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","names":["notifyManager","Mutation","matchMutation","noop","Subscribable","MutationCache","config","Map","Date","now","client","options","state","mutation","mutationCache","mutationId","defaultMutationOptions","add","scope","scopeFor","mutations","get","push","set","notify","type","has","filter","x","length","delete","firstPendingMutation","find","m","status","foundMutation","isPaused","continue","Promise","resolve","batch","getAll","forEach","remove","values","flat","filters","defaultedFilters","exact","event","listeners","listener","pausedMutations","all","map","catch","id","String"],"sources":["/Users/andrew/node_modules/@tanstack/query-core/src/mutationCache.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Map()\n    this.#mutationId = Date.now()\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    const scope = scopeFor(mutation)\n    const mutations = this.#mutations.get(scope) ?? []\n    mutations.push(mutation)\n    this.#mutations.set(scope, mutations)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    const scope = scopeFor(mutation)\n    if (this.#mutations.has(scope)) {\n      const mutations = this.#mutations\n        .get(scope)\n        ?.filter((x) => x !== mutation)\n      if (mutations) {\n        if (mutations.length === 0) {\n          this.#mutations.delete(scope)\n        } else {\n          this.#mutations.set(scope, mutations)\n        }\n      }\n    }\n\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const firstPendingMutation = this.#mutations\n      .get(scopeFor(mutation))\n      ?.find((m) => m.state.status === 'pending')\n\n    // we can run if there is no current pending mutation (start use-case)\n    // or if WE are the first pending mutation (continue use-case)\n    return !firstPendingMutation || firstPendingMutation === mutation\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const foundMutation = this.#mutations\n      .get(scopeFor(mutation))\n      ?.find((m) => m !== mutation && m.state.isPaused)\n\n    return foundMutation?.continue() ?? Promise.resolve()\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return [...this.#mutations.values()].flat()\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id ?? String(mutation.mutationId)\n}\n"]},"metadata":{},"sourceType":"module"}