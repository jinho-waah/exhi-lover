{"ast":null,"code":"\"use client\"; // src/useBaseQuery.ts\n\nimport _slicedToArray from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from \"react\";\nimport { notifyManager } from \"@tanstack/query-core\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary } from \"./errorBoundaryUtils.js\";\nimport { ensureSuspenseTimers, fetchOptimistic, shouldSuspend } from \"./suspense.js\";\n\nfunction useBaseQuery(options, Observer, queryClient) {\n  var _client$getDefaultOpt, _client$getDefaultOpt2, _client$getDefaultOpt3, _client$getDefaultOpt4;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error('Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object');\n    }\n  }\n\n  var client = useQueryClient(queryClient);\n  var isRestoring = useIsRestoring();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = client.defaultQueryOptions(options);\n  (_client$getDefaultOpt = client.getDefaultOptions().queries) === null || _client$getDefaultOpt === void 0 ? void 0 : (_client$getDefaultOpt2 = _client$getDefaultOpt._experimental_beforeQuery) === null || _client$getDefaultOpt2 === void 0 ? void 0 : _client$getDefaultOpt2.call(_client$getDefaultOpt, defaultedOptions);\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n\n  var _React$useState = React.useState(function () {\n    return new Observer(client, defaultedOptions);\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 1),\n      observer = _React$useState2[0];\n\n  var result = observer.getOptimisticResult(defaultedOptions);\n  React.useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    var unsubscribe = isRestoring ? function () {\n      return void 0;\n    } : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n    observer.updateResult();\n    return unsubscribe;\n  }, [observer, isRestoring]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]);\n\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n\n  if (getHasError({\n    result: result,\n    errorResetBoundary: errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: client.getQueryCache().get(defaultedOptions.queryHash)\n  })) {\n    throw result.error;\n  }\n\n  ;\n  (_client$getDefaultOpt3 = client.getDefaultOptions().queries) === null || _client$getDefaultOpt3 === void 0 ? void 0 : (_client$getDefaultOpt4 = _client$getDefaultOpt3._experimental_afterQuery) === null || _client$getDefaultOpt4 === void 0 ? void 0 : _client$getDefaultOpt4.call(_client$getDefaultOpt3, defaultedOptions, result);\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n\nexport { useBaseQuery };","map":{"version":3,"mappings":";;;AACA,YAAYA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,aAAT,QAA8B,sBAA9B;AACA,SAASC,0BAAT,QAA2C,8BAA3C;AACA,SAASC,cAAT,QAA+B,0BAA/B;AACA,SAASC,cAAT,QAA+B,kBAA/B;AACA,SACEC,+BADF,EAEEC,WAFF,EAGEC,0BAHF,QAIO,yBAJP;AAKA,SACEC,oBADF,EAEEC,eAFF,EAGEC,aAHF,QAIO,eAJP;;AAaO,SAASC,YAAT,CAOLC,OAPK,EAcLC,QAdK,EAeLC,WAfK,EAgB+B;EAAA;;EACpC,IAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC,IAAI,OAAOL,OAAP,KAAmB,QAAnB,IAA+BM,MAAMC,OAAN,CAAcP,OAAd,CAAnC,EAA2D;MACzD,MAAM,IAAIQ,KAAJ,CACJ,8RADI,CAAN;IAGF;EACF;;EAEA,IAAMC,SAASlB,eAAeW,WAAf,CAAf;EACA,IAAMQ,cAAclB,gBAApB;EACA,IAAMmB,qBAAqBrB,4BAA3B;EACA,IAAMsB,mBAAmBH,OAAOI,mBAAP,CAA2Bb,OAA3B,CAAzB;EAEE,gCAAOc,iBAAP,GAA2BC,OAA3B,0GAA4CC,yBAA5C,8GACAJ,gBADA;EAKFA,iBAAiBK,kBAAjB,GAAsCP,cAClC,aADkC,GAElC,YAFJ;EAIAd,qBAAqBgB,gBAArB;EACAnB,gCAAgCmB,gBAAhC,EAAkDD,kBAAlD;EAEAhB,2BAA2BgB,kBAA3B;;EAEA,sBAAyBvB,eACvB;IAAA,OACE,IAAIa,QAAJ,CACEQ,MADF,EAEEG,gBAFF,CADF;EAAA,CADuB,CAAzB;EAAA;EAAA,IAAOM,QAAP;;EAQA,IAAMC,SAASD,SAASE,mBAAT,CAA6BR,gBAA7B,CAAf;EAEMxB,2BACEA,kBACJ,UAACiC,aAAD,EAAmB;IACjB,IAAMC,cAAcZ,cAChB;MAAA,OAAM,MAAN;IAAA,CADgB,GAEhBQ,SAASK,SAAT,CAAmBlC,cAAcmC,UAAd,CAAyBH,aAAzB,CAAnB,CAFJ;IAMAH,SAASO,YAAT;IAEA,OAAOH,WAAP;EACF,CAXI,EAYJ,CAACJ,QAAD,EAAWR,WAAX,CAZI,CADF,EAeJ;IAAA,OAAMQ,SAASQ,gBAAT,EAAN;EAAA,CAfI,EAgBJ;IAAA,OAAMR,SAASQ,gBAAT,EAAN;EAAA,CAhBI;EAmBAtC,gBAAU,YAAM;IAGpB8B,SAASS,UAAT,CAAoBf,gBAApB,EAAsC;MAAEgB,WAAW;IAAb,CAAtC;EACF,CAJM,EAIH,CAAChB,gBAAD,EAAmBM,QAAnB,CAJG;;EAON,IAAIpB,cAAcc,gBAAd,EAAgCO,MAAhC,CAAJ,EAA6C;IAC3C,MAAMtB,gBAAgBe,gBAAhB,EAAkCM,QAAlC,EAA4CP,kBAA5C,CAAN;EACF;;EAGA,IACEjB,YAAY;IACVyB,cADU;IAEVR,sCAFU;IAGVkB,cAAcjB,iBAAiBiB,YAHrB;IAIVC,OAAOrB,OACJsB,aADI,GAEJC,GAFI,CAOHpB,iBAAiBqB,SAPd;EAJG,CAAZ,CADF,EAcE;IACA,MAAMd,OAAOe,KAAb;EACF;;EAEA;EAAE,iCAAOpB,iBAAP,GAA2BC,OAA3B,4GAA4CoB,wBAA5C,+GACAvB,gBADA,EAEAO,MAFA;EAMF,OAAO,CAACP,iBAAiBwB,mBAAlB,GACHlB,SAASmB,WAAT,CAAqBlB,MAArB,CADG,GAEHA,MAFJ;AAGF","names":["React","notifyManager","useQueryErrorResetBoundary","useQueryClient","useIsRestoring","ensurePreventErrorBoundaryRetry","getHasError","useClearResetErrorBoundary","ensureSuspenseTimers","fetchOptimistic","shouldSuspend","useBaseQuery","options","Observer","queryClient","process","env","NODE_ENV","Array","isArray","Error","client","isRestoring","errorResetBoundary","defaultedOptions","defaultQueryOptions","getDefaultOptions","queries","_experimental_beforeQuery","_optimisticResults","observer","result","getOptimisticResult","onStoreChange","unsubscribe","subscribe","batchCalls","updateResult","getCurrentResult","setOptions","listeners","throwOnError","query","getQueryCache","get","queryHash","error","_experimental_afterQuery","notifyOnChangeProps","trackResult"],"sources":["/Users/andrew/node_modules/@tanstack/react-query/src/useBaseQuery.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n} from './suspense'\nimport type { UseBaseQueryOptions } from './types'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n"]},"metadata":{},"sourceType":"module"}