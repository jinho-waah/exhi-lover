{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onClick\", \"onKeyDown\", \"onFocus\", \"onBlur\", \"onMouseUp\", \"onPaste\", \"error\"];\nimport * as React from 'react';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useValidation } from '../validation/useValidation';\nimport { useUtils } from '../useUtils';\nimport { adjustSectionValue, isAndroid, cleanString } from './useField.utils';\nimport { useFieldState } from './useFieldState';\nimport { useFieldCharacterEditing } from './useFieldCharacterEditing';\nimport { getActiveElement } from '../../utils/utils';\nexport const useField = params => {\n  const utils = useUtils();\n  const {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionOrder,\n    sectionsValueBoundaries\n  } = useFieldState(params);\n  const {\n    applyCharacterEditing,\n    resetCharacterQuery\n  } = useFieldCharacterEditing({\n    sections: state.sections,\n    updateSectionValue,\n    sectionsValueBoundaries,\n    setTempAndroidValueStr\n  });\n\n  const {\n    inputRef: inputRefProp,\n    internalProps,\n    internalProps: {\n      readOnly = false\n    },\n    forwardedProps: {\n      onClick,\n      onKeyDown,\n      onFocus,\n      onBlur,\n      onMouseUp,\n      onPaste,\n      error\n    },\n    fieldValueManager,\n    valueManager,\n    validator\n  } = params,\n        otherForwardedProps = _objectWithoutPropertiesLoose(params.forwardedProps, _excluded);\n\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const focusTimeoutRef = React.useRef(undefined);\n\n  const syncSelectionFromDOM = () => {\n    var _selectionStart;\n\n    if (readOnly) {\n      setSelectedSections(null);\n      return;\n    }\n\n    const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;\n    const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n    : state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n\n  const handleInputClick = useEventCallback(function () {\n    onClick == null ? void 0 : onClick(...arguments);\n    syncSelectionFromDOM();\n  });\n  const handleInputMouseUp = useEventCallback(event => {\n    onMouseUp == null ? void 0 : onMouseUp(event); // Without this, the browser will remove the selected when clicking inside an already-selected section.\n\n    event.preventDefault();\n  });\n  const handleInputFocus = useEventCallback(function () {\n    onFocus == null ? void 0 : onFocus(...arguments); // The ref is guaranteed to be resolved at this point.\n\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n\n      if (selectedSectionIndexes != null || readOnly) {\n        return;\n      }\n\n      if ( // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputBlur = useEventCallback(function () {\n    onBlur == null ? void 0 : onBlur(...arguments);\n    setSelectedSections(null);\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste == null ? void 0 : onPaste(event);\n\n    if (readOnly) {\n      event.preventDefault();\n      return;\n    }\n\n    const pastedValue = event.clipboardData.getData('text');\n\n    if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly;\n\n      if (isValidPastedValue) {\n        // Early return to let the paste update section, value\n        return;\n      }\n\n      if (lettersOnly || digitsOnly) {\n        // The pasted value correspond to a single section but not the expected type\n        // skip the modification\n        event.preventDefault();\n        return;\n      }\n    }\n\n    event.preventDefault();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n\n    const valueStr = event.target.value;\n    const cleanValueStr = cleanString(valueStr); // If no section is selected, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n\n    if (selectedSectionIndexes == null) {\n      updateValueFromValueStr(cleanValueStr);\n      return;\n    }\n\n    const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections));\n    let startOfDiffIndex = -1;\n    let endOfDiffIndex = -1;\n\n    for (let i = 0; i < prevValueStr.length; i += 1) {\n      if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n        startOfDiffIndex = i;\n      }\n\n      if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n        endOfDiffIndex = i;\n      }\n    }\n\n    const activeSection = state.sections[selectedSectionIndexes.startIndex];\n    const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n\n    if (hasDiffOutsideOfActiveSection) {\n      // TODO: Support if the new date is valid\n      return;\n    } // The active section being selected, the browser has replaced its value with the key pressed by the user.\n\n\n    const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n    const keyPressed = cleanValueStr.slice(activeSection.start, activeSectionEndRelativeToNewValue);\n\n    if (isAndroid() && keyPressed.length === 0) {\n      setTempAndroidValueStr(valueStr);\n      return;\n    }\n\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: selectedSectionIndexes.startIndex\n    });\n  });\n  const handleInputKeyDown = useEventCallback(event => {\n    onKeyDown == null ? void 0 : onKeyDown(event); // eslint-disable-next-line default-case\n\n    switch (true) {\n      // Select all\n      case event.key === 'a' && (event.ctrlKey || event.metaKey):\n        {\n          // prevent default to make sure that the next line \"select all\" while updating\n          // the internal state at the same time.\n          event.preventDefault();\n          setSelectedSections('all');\n          break;\n        }\n      // Move selection to next section\n\n      case event.key === 'ArrowRight':\n        {\n          event.preventDefault();\n\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.startIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.endIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;\n\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n\n          break;\n        }\n      // Move selection to previous section\n\n      case event.key === 'ArrowLeft':\n        {\n          event.preventDefault();\n\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.endIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.startIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;\n\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n\n          break;\n        }\n      // Reset the value of the selected section\n\n      case ['Backspace', 'Delete'].includes(event.key):\n        {\n          event.preventDefault();\n\n          if (readOnly) {\n            break;\n          }\n\n          if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {\n            clearValue();\n          } else {\n            clearActiveSection();\n          }\n\n          resetCharacterQuery();\n          break;\n        }\n      // Increment / decrement the selected section value\n\n      case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key):\n        {\n          event.preventDefault();\n\n          if (readOnly || selectedSectionIndexes == null) {\n            break;\n          }\n\n          const activeSection = state.sections[selectedSectionIndexes.startIndex];\n          const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n          const newSectionValue = adjustSectionValue(utils, activeSection, event.key, sectionsValueBoundaries, activeDateManager.activeDate);\n          updateSectionValue({\n            activeSection,\n            newSectionValue,\n            shouldGoToNextSection: false\n          });\n          break;\n        }\n    }\n  });\n  useEnhancedEffect(() => {\n    if (selectedSectionIndexes == null) {\n      if (inputRef.current.selectionStart !== 0 || inputRef.current.selectionEnd !== 0) {\n        // Ensure input selection range is in sync with component selection indexes\n        inputRef.current.setSelectionRange(0, 0);\n      }\n\n      return;\n    }\n\n    const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];\n    const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];\n    let selectionStart = firstSelectedSection.startInInput;\n    let selectionEnd = lastSelectedSection.endInInput;\n\n    if (selectedSectionIndexes.shouldSelectBoundarySelectors) {\n      selectionStart -= firstSelectedSection.startSeparator.length;\n      selectionEnd += lastSelectedSection.endSeparator.length;\n    }\n\n    if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n      inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n    }\n  });\n  const validationError = useValidation(_extends({}, internalProps, {\n    value: state.value\n  }), validator, valueManager.isSameError, valueManager.defaultErrorState);\n  const inputError = React.useMemo(() => {\n    // only override when `error` is undefined.\n    // in case of multi input fields, the `error` value is provided externally and will always be defined.\n    if (error !== undefined) {\n      return error;\n    }\n\n    return fieldValueManager.hasError(validationError);\n  }, [fieldValueManager, validationError, error]);\n  React.useEffect(() => {\n    // Select the right section when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === document.activeElement) {\n      setSelectedSections('all');\n    }\n\n    return () => window.clearTimeout(focusTimeoutRef.current);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n  // If `state.tempValueStrAndroid` is still defined when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {\n      resetCharacterQuery();\n      clearActiveSection();\n    }\n  }, [state.tempValueStrAndroid]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const valueStr = React.useMemo(() => {\n    var _state$tempValueStrAn;\n\n    return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections);\n  }, [state.sections, fieldValueManager, state.tempValueStrAndroid]);\n  const inputMode = React.useMemo(() => {\n    if (selectedSectionIndexes == null) {\n      return 'text';\n    }\n\n    if (state.sections[selectedSectionIndexes.startIndex].contentType === 'letter') {\n      return 'text';\n    }\n\n    return 'tel';\n  }, [selectedSectionIndexes, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const shouldShowPlaceholder = !inputHasFocus && (!state.value || valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue));\n  return _extends({\n    placeholder: state.placeholder,\n    autoComplete: 'off'\n  }, otherForwardedProps, {\n    value: shouldShowPlaceholder ? '' : valueStr,\n    inputMode,\n    readOnly,\n    onClick: handleInputClick,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onPaste: handleInputPaste,\n    onChange: handleInputChange,\n    onKeyDown: handleInputKeyDown,\n    onMouseUp: handleInputMouseUp,\n    error: inputError,\n    ref: handleRef\n  });\n};","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","_excluded","React","useEnhancedEffect","useEventCallback","useForkRef","useValidation","useUtils","adjustSectionValue","isAndroid","cleanString","useFieldState","useFieldCharacterEditing","getActiveElement","useField","params","utils","state","selectedSectionIndexes","setSelectedSections","clearValue","clearActiveSection","updateSectionValue","updateValueFromValueStr","setTempAndroidValueStr","sectionOrder","sectionsValueBoundaries","applyCharacterEditing","resetCharacterQuery","sections","inputRef","inputRefProp","internalProps","readOnly","forwardedProps","onClick","onKeyDown","onFocus","onBlur","onMouseUp","onPaste","error","fieldValueManager","valueManager","validator","otherForwardedProps","useRef","handleRef","focusTimeoutRef","undefined","syncSelectionFromDOM","_selectionStart","browserStartIndex","current","selectionStart","nextSectionIndex","startInInput","findIndex","section","startSeparator","length","sectionIndex","handleInputClick","handleInputMouseUp","event","preventDefault","handleInputFocus","input","clearTimeout","setTimeout","value","Number","selectionEnd","handleInputBlur","handleInputPaste","pastedValue","clipboardData","getData","startIndex","endIndex","activeSection","lettersOnly","test","digitsOnly","isValidPastedValue","contentType","handleInputChange","valueStr","target","cleanValueStr","prevValueStr","getValueStrFromSections","startOfDiffIndex","endOfDiffIndex","i","hasDiffOutsideOfActiveSection","start","end","activeSectionEndRelativeToNewValue","endSeparator","keyPressed","slice","handleInputKeyDown","key","ctrlKey","metaKey","neighbors","rightIndex","leftIndex","includes","activeDateManager","getActiveDateManager","newSectionValue","activeDate","shouldGoToNextSection","setSelectionRange","firstSelectedSection","lastSelectedSection","endInInput","shouldSelectBoundarySelectors","validationError","isSameError","defaultErrorState","inputError","useMemo","hasError","useEffect","document","activeElement","window","tempValueStrAndroid","_state$tempValueStrAn","inputMode","inputHasFocus","shouldShowPlaceholder","areValuesEqual","emptyValue","placeholder","autoComplete","onChange","ref"],"sources":["/Users/andrew/Desktop/exhi/exhi/client/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onClick\", \"onKeyDown\", \"onFocus\", \"onBlur\", \"onMouseUp\", \"onPaste\", \"error\"];\nimport * as React from 'react';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useValidation } from '../validation/useValidation';\nimport { useUtils } from '../useUtils';\nimport { adjustSectionValue, isAndroid, cleanString } from './useField.utils';\nimport { useFieldState } from './useFieldState';\nimport { useFieldCharacterEditing } from './useFieldCharacterEditing';\nimport { getActiveElement } from '../../utils/utils';\nexport const useField = params => {\n  const utils = useUtils();\n  const {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionOrder,\n    sectionsValueBoundaries\n  } = useFieldState(params);\n  const {\n    applyCharacterEditing,\n    resetCharacterQuery\n  } = useFieldCharacterEditing({\n    sections: state.sections,\n    updateSectionValue,\n    sectionsValueBoundaries,\n    setTempAndroidValueStr\n  });\n  const {\n      inputRef: inputRefProp,\n      internalProps,\n      internalProps: {\n        readOnly = false\n      },\n      forwardedProps: {\n        onClick,\n        onKeyDown,\n        onFocus,\n        onBlur,\n        onMouseUp,\n        onPaste,\n        error\n      },\n      fieldValueManager,\n      valueManager,\n      validator\n    } = params,\n    otherForwardedProps = _objectWithoutPropertiesLoose(params.forwardedProps, _excluded);\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const focusTimeoutRef = React.useRef(undefined);\n  const syncSelectionFromDOM = () => {\n    var _selectionStart;\n    if (readOnly) {\n      setSelectedSections(null);\n      return;\n    }\n    const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;\n    const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n    : state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n  const handleInputClick = useEventCallback((...args) => {\n    onClick == null ? void 0 : onClick(...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputMouseUp = useEventCallback(event => {\n    onMouseUp == null ? void 0 : onMouseUp(event);\n\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const handleInputFocus = useEventCallback((...args) => {\n    onFocus == null ? void 0 : onFocus(...args);\n    // The ref is guaranteed to be resolved at this point.\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n      if (selectedSectionIndexes != null || readOnly) {\n        return;\n      }\n      if (\n      // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputBlur = useEventCallback((...args) => {\n    onBlur == null ? void 0 : onBlur(...args);\n    setSelectedSections(null);\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste == null ? void 0 : onPaste(event);\n    if (readOnly) {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly;\n      if (isValidPastedValue) {\n        // Early return to let the paste update section, value\n        return;\n      }\n      if (lettersOnly || digitsOnly) {\n        // The pasted value correspond to a single section but not the expected type\n        // skip the modification\n        event.preventDefault();\n        return;\n      }\n    }\n    event.preventDefault();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n    const valueStr = event.target.value;\n    const cleanValueStr = cleanString(valueStr);\n\n    // If no section is selected, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n    if (selectedSectionIndexes == null) {\n      updateValueFromValueStr(cleanValueStr);\n      return;\n    }\n    const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections));\n    let startOfDiffIndex = -1;\n    let endOfDiffIndex = -1;\n    for (let i = 0; i < prevValueStr.length; i += 1) {\n      if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n        startOfDiffIndex = i;\n      }\n      if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n        endOfDiffIndex = i;\n      }\n    }\n    const activeSection = state.sections[selectedSectionIndexes.startIndex];\n    const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n    if (hasDiffOutsideOfActiveSection) {\n      // TODO: Support if the new date is valid\n      return;\n    }\n\n    // The active section being selected, the browser has replaced its value with the key pressed by the user.\n    const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n    const keyPressed = cleanValueStr.slice(activeSection.start, activeSectionEndRelativeToNewValue);\n    if (isAndroid() && keyPressed.length === 0) {\n      setTempAndroidValueStr(valueStr);\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: selectedSectionIndexes.startIndex\n    });\n  });\n  const handleInputKeyDown = useEventCallback(event => {\n    onKeyDown == null ? void 0 : onKeyDown(event);\n\n    // eslint-disable-next-line default-case\n    switch (true) {\n      // Select all\n      case event.key === 'a' && (event.ctrlKey || event.metaKey):\n        {\n          // prevent default to make sure that the next line \"select all\" while updating\n          // the internal state at the same time.\n          event.preventDefault();\n          setSelectedSections('all');\n          break;\n        }\n\n      // Move selection to next section\n      case event.key === 'ArrowRight':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.startIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.endIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Move selection to previous section\n      case event.key === 'ArrowLeft':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.endIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.startIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Reset the value of the selected section\n      case ['Backspace', 'Delete'].includes(event.key):\n        {\n          event.preventDefault();\n          if (readOnly) {\n            break;\n          }\n          if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {\n            clearValue();\n          } else {\n            clearActiveSection();\n          }\n          resetCharacterQuery();\n          break;\n        }\n\n      // Increment / decrement the selected section value\n      case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key):\n        {\n          event.preventDefault();\n          if (readOnly || selectedSectionIndexes == null) {\n            break;\n          }\n          const activeSection = state.sections[selectedSectionIndexes.startIndex];\n          const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n          const newSectionValue = adjustSectionValue(utils, activeSection, event.key, sectionsValueBoundaries, activeDateManager.activeDate);\n          updateSectionValue({\n            activeSection,\n            newSectionValue,\n            shouldGoToNextSection: false\n          });\n          break;\n        }\n    }\n  });\n  useEnhancedEffect(() => {\n    if (selectedSectionIndexes == null) {\n      if (inputRef.current.selectionStart !== 0 || inputRef.current.selectionEnd !== 0) {\n        // Ensure input selection range is in sync with component selection indexes\n        inputRef.current.setSelectionRange(0, 0);\n      }\n      return;\n    }\n    const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];\n    const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];\n    let selectionStart = firstSelectedSection.startInInput;\n    let selectionEnd = lastSelectedSection.endInInput;\n    if (selectedSectionIndexes.shouldSelectBoundarySelectors) {\n      selectionStart -= firstSelectedSection.startSeparator.length;\n      selectionEnd += lastSelectedSection.endSeparator.length;\n    }\n    if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n      inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n    }\n  });\n  const validationError = useValidation(_extends({}, internalProps, {\n    value: state.value\n  }), validator, valueManager.isSameError, valueManager.defaultErrorState);\n  const inputError = React.useMemo(() => {\n    // only override when `error` is undefined.\n    // in case of multi input fields, the `error` value is provided externally and will always be defined.\n    if (error !== undefined) {\n      return error;\n    }\n    return fieldValueManager.hasError(validationError);\n  }, [fieldValueManager, validationError, error]);\n  React.useEffect(() => {\n    // Select the right section when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === document.activeElement) {\n      setSelectedSections('all');\n    }\n    return () => window.clearTimeout(focusTimeoutRef.current);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // If `state.tempValueStrAndroid` is still defined when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {\n      resetCharacterQuery();\n      clearActiveSection();\n    }\n  }, [state.tempValueStrAndroid]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const valueStr = React.useMemo(() => {\n    var _state$tempValueStrAn;\n    return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections);\n  }, [state.sections, fieldValueManager, state.tempValueStrAndroid]);\n  const inputMode = React.useMemo(() => {\n    if (selectedSectionIndexes == null) {\n      return 'text';\n    }\n    if (state.sections[selectedSectionIndexes.startIndex].contentType === 'letter') {\n      return 'text';\n    }\n    return 'tel';\n  }, [selectedSectionIndexes, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const shouldShowPlaceholder = !inputHasFocus && (!state.value || valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue));\n  return _extends({\n    placeholder: state.placeholder,\n    autoComplete: 'off'\n  }, otherForwardedProps, {\n    value: shouldShowPlaceholder ? '' : valueStr,\n    inputMode,\n    readOnly,\n    onClick: handleInputClick,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onPaste: handleInputPaste,\n    onChange: handleInputChange,\n    onKeyDown: handleInputKeyDown,\n    onMouseUp: handleInputMouseUp,\n    error: inputError,\n    ref: handleRef\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}