{"ast":null,"code":"import _createClass from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\n// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { isServer, sleep } from \"./utils.js\";\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * Math.pow(2, failureCount), 3e4);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode !== null && networkMode !== void 0 ? networkMode : \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\n\nvar CancelledError = /*#__PURE__*/function (_Error) {\n  _inherits(CancelledError, _Error);\n\n  var _super = _createSuper(CancelledError);\n\n  function CancelledError(options) {\n    var _this;\n\n    _classCallCheck(this, CancelledError);\n\n    _this = _super.call(this, \"CancelledError\");\n    _this.revert = options === null || options === void 0 ? void 0 : options.revert;\n    _this.silent = options === null || options === void 0 ? void 0 : options.silent;\n    return _this;\n  }\n\n  return _createClass(CancelledError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\n\nfunction createRetryer(config) {\n  var isRetryCancelled = false;\n  var failureCount = 0;\n  var isResolved = false;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n  var promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var cancel = function cancel(cancelOptions) {\n    if (!isResolved) {\n      var _config$abort;\n\n      reject(new CancelledError(cancelOptions));\n      (_config$abort = config.abort) === null || _config$abort === void 0 ? void 0 : _config$abort.call(config);\n    }\n  };\n\n  var cancelRetry = function cancelRetry() {\n    isRetryCancelled = true;\n  };\n\n  var continueRetry = function continueRetry() {\n    isRetryCancelled = false;\n  };\n\n  var canContinue = function canContinue() {\n    return focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n  };\n\n  var canStart = function canStart() {\n    return canFetch(config.networkMode) && config.canRun();\n  };\n\n  var resolve = function resolve(value) {\n    if (!isResolved) {\n      var _config$onSuccess, _continueFn;\n\n      isResolved = true;\n      (_config$onSuccess = config.onSuccess) === null || _config$onSuccess === void 0 ? void 0 : _config$onSuccess.call(config, value);\n      (_continueFn = continueFn) === null || _continueFn === void 0 ? void 0 : _continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!isResolved) {\n      var _config$onError, _continueFn2;\n\n      isResolved = true;\n      (_config$onError = config.onError) === null || _config$onError === void 0 ? void 0 : _config$onError.call(config, value);\n      (_continueFn2 = continueFn) === null || _continueFn2 === void 0 ? void 0 : _continueFn2();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      var _config$onPause;\n\n      continueFn = function continueFn(value) {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n\n      (_config$onPause = config.onPause) === null || _config$onPause === void 0 ? void 0 : _config$onPause.call(config);\n    }).then(function () {\n      continueFn = void 0;\n\n      if (!isResolved) {\n        var _config$onContinue;\n\n        (_config$onContinue = config.onContinue) === null || _config$onContinue === void 0 ? void 0 : _config$onContinue.call(config);\n      }\n    });\n  };\n\n  var run = function run() {\n    if (isResolved) {\n      return;\n    }\n\n    var promiseOrValue;\n    var initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n\n    try {\n      promiseOrValue = initialPromise !== null && initialPromise !== void 0 ? initialPromise : config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay, _config$onFail;\n\n      if (isResolved) {\n        return;\n      }\n\n      var retry = (_config$retry = config.retry) !== null && _config$retry !== void 0 ? _config$retry : isServer ? 0 : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) !== null && _config$retryDelay !== void 0 ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n\n      failureCount++;\n      (_config$onFail = config.onFail) === null || _config$onFail === void 0 ? void 0 : _config$onFail.call(config, failureCount, error);\n      sleep(delay).then(function () {\n        return canContinue() ? void 0 : pause();\n      }).then(function () {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n\n  return {\n    promise: promise,\n    cancel: cancel,\n    continue: function _continue() {\n      var _continueFn3;\n\n      (_continueFn3 = continueFn) === null || _continueFn3 === void 0 ? void 0 : _continueFn3();\n      return promise;\n    },\n    cancelRetry: cancelRetry,\n    continueRetry: continueRetry,\n    canStart: canStart,\n    start: function start() {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n\n      return promise;\n    }\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,YAAT,QAA6B,mBAA7B;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,QAAT,EAAmBC,KAAnB,QAAgC,YAAhC;;AA4CA,SAASC,iBAAT,CAA2BC,YAA3B,EAAiD;EAC/C,OAAOC,KAAKC,GAAL,CAAS,eAAO,CAAP,EAAYF,YAAZ,CAAT,EAAmC,GAAnC,CAAP;AACF;;AAEO,SAASG,QAAT,CAAkBC,WAAlB,EAAiE;EACtE,QAAQA,WAAR,aAAQA,WAAR,cAAQA,WAAR,GAAuB,QAAvB,MAAqC,QAArC,GACIR,cAAcS,QAAd,EADJ,GAEI,IAFJ;AAGF;;AAEO,IAAMC;EAAA;;EAAA;;EAGX,wBAAYC,OAAZ,EAAqC;IAAA;;IAAA;;IACnC,0BAAM,gBAAN;IACA,MAAKC,MAAL,GAAcD,OAAd,aAAcA,OAAd,uBAAcA,QAASC,MAAvB;IACA,MAAKC,MAAL,GAAcF,OAAd,aAAcA,OAAd,uBAAcA,QAASE,MAAvB;IAHmC;EAIrC;;EAPW;AAAA,iCAAuBC,KAAvB,EAAN;;AAUA,SAASC,gBAAT,CAA0BC,KAA1B,EAA+D;EACpE,OAAOA,iBAAiBN,cAAxB;AACF;;AAEO,SAASO,aAAT,CACLC,MADK,EAEW;EAChB,IAAIC,mBAAmB,KAAvB;EACA,IAAIf,eAAe,CAAnB;EACA,IAAIgB,aAAa,KAAjB;EACA,IAAIC,UAAJ;EACA,IAAIC,cAAJ;EACA,IAAIC,aAAJ;EAEA,IAAMC,UAAU,IAAIC,OAAJ,CAAmB,UAACC,YAAD,EAAeC,WAAf,EAA+B;IAChEL,iBAAiBI,YAAjB;IACAH,gBAAgBI,WAAhB;EACD,CAHe,CAAhB;;EAKA,IAAMC,SAAS,SAATA,MAAS,CAACC,aAAD,EAAyC;IACtD,IAAI,CAACT,UAAL,EAAiB;MAAA;;MACfU,OAAO,IAAIpB,cAAJ,CAAmBmB,aAAnB,CAAP;MAEA,wBAAOE,KAAP;IACF;EACF,CANA;;EAOA,IAAMC,cAAc,SAAdA,WAAc,GAAM;IACxBb,mBAAmB,IAAnB;EACF,CAFA;;EAIA,IAAMc,gBAAgB,SAAhBA,aAAgB,GAAM;IAC1Bd,mBAAmB,KAAnB;EACF,CAFA;;EAIA,IAAMe,cAAc,SAAdA,WAAc;IAAA,OAClBnC,aAAaoC,SAAb,OACCjB,OAAOV,WAAP,KAAuB,QAAvB,IAAmCR,cAAcS,QAAd,EADpC,KAEAS,OAAOkB,MAAP,EAHkB;EAAA,CAApB;;EAKA,IAAMC,WAAW,SAAXA,QAAW;IAAA,OAAM9B,SAASW,OAAOV,WAAhB,KAAgCU,OAAOkB,MAAP,EAAtC;EAAA,CAAjB;;EAEA,IAAME,UAAU,SAAVA,OAAU,CAACtB,KAAD,EAAgB;IAC9B,IAAI,CAACI,UAAL,EAAiB;MAAA;;MACfA,aAAa,IAAb;MACA,4BAAOmB,SAAP,qFAAmBvB,KAAnB;MACA;MACAM,eAAeN,KAAf;IACF;EACF,CAPA;;EASA,IAAMc,SAAS,SAATA,MAAS,CAACd,KAAD,EAAgB;IAC7B,IAAI,CAACI,UAAL,EAAiB;MAAA;;MACfA,aAAa,IAAb;MACA,0BAAOoB,OAAP,iFAAiBxB,KAAjB;MACA;MACAO,cAAcP,KAAd;IACF;EACF,CAPA;;EASA,IAAMyB,QAAQ,SAARA,KAAQ,GAAM;IAClB,OAAO,IAAIhB,OAAJ,CAAY,UAACiB,eAAD,EAAqB;MAAA;;MACtCrB,aAAa,oBAACL,KAAD,EAAW;QACtB,IAAII,cAAcc,aAAlB,EAAiC;UAC/BQ,gBAAgB1B,KAAhB;QACF;MACF,CAJA;;MAKA,0BAAO2B,OAAP;IACD,CAPM,EAOJC,IAPI,CAOC,YAAM;MACZvB,aAAa,MAAb;;MACA,IAAI,CAACD,UAAL,EAAiB;QAAA;;QACf,6BAAOyB,UAAP;MACF;IACD,CAZM,CAAP;EAaF,CAdA;;EAiBA,IAAMC,MAAM,SAANA,GAAM,GAAM;IAEhB,IAAI1B,UAAJ,EAAgB;MACd;IACF;;IAEA,IAAI2B,cAAJ;IAGA,IAAMC,iBACJ5C,iBAAiB,CAAjB,GAAqBc,OAAO8B,cAA5B,GAA6C,MAD/C;;IAIA,IAAI;MACFD,iBAAiBC,cAAjB,aAAiBA,cAAjB,cAAiBA,cAAjB,GAAmC9B,OAAO+B,EAAP,EAAnC;IACF,CAFA,CAEA,OAASC,KAAT,EAAgB;MACdH,iBAAiBtB,QAAQK,MAAR,CAAeoB,KAAf,CAAjB;IACF;;IAEAzB,QAAQa,OAAR,CAAgBS,cAAhB,EACGH,IADH,CACQN,OADR,EAEGa,KAFH,CAES,UAACD,KAAD,EAAW;MAAA;;MAEhB,IAAI9B,UAAJ,EAAgB;QACd;MACF;;MAGA,IAAMgC,yBAAQlC,OAAOkC,KAAf,yDAAyBnD,WAAW,CAAX,GAAe,CAA9C;MACA,IAAMoD,mCAAanC,OAAOmC,UAApB,mEAAkClD,iBAAxC;MACA,IAAMmD,QACJ,OAAOD,UAAP,KAAsB,UAAtB,GACIA,WAAWjD,YAAX,EAAyB8C,KAAzB,CADJ,GAEIG,UAHN;MAIA,IAAME,cACJH,UAAU,IAAV,IACC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BhD,eAAegD,KAD7C,IAEC,OAAOA,KAAP,KAAiB,UAAjB,IAA+BA,MAAMhD,YAAN,EAAoB8C,KAApB,CAHlC;;MAKA,IAAI/B,oBAAoB,CAACoC,WAAzB,EAAsC;QAEpCzB,OAAOoB,KAAP;QACA;MACF;;MAEA9C;MAGA,yBAAOoD,MAAP,+EAAgBpD,YAAhB,EAA8B8C,KAA9B;MAGAhD,MAAMoD,KAAN,EAEGV,IAFH,CAEQ,YAAM;QACV,OAAOV,gBAAgB,MAAhB,GAA4BO,OAAnC;MACD,CAJH,EAKGG,IALH,CAKQ,YAAM;QACV,IAAIzB,gBAAJ,EAAsB;UACpBW,OAAOoB,KAAP;QACF,CAFA,MAEO;UACLJ;QACF;MACD,CAXH;IAYD,CA5CH;EA6CF,CAhEA;;EAkEA,OAAO;IACLtB,gBADK;IAELI,cAFK;IAGL6B,UAAU,qBAAM;MAAA;;MACd;MACA,OAAOjC,OAAP;IACF,CANK;IAOLQ,wBAPK;IAQLC,4BARK;IASLI,kBATK;IAULqB,OAAO,iBAAM;MAEX,IAAIrB,UAAJ,EAAgB;QACdS;MACF,CAFA,MAEO;QACLL,QAAQG,IAAR,CAAaE,GAAb;MACF;;MACA,OAAOtB,OAAP;IACF;EAlBK,CAAP;AAoBF","names":["focusManager","onlineManager","isServer","sleep","defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","isOnline","CancelledError","options","revert","silent","Error","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","Promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","canContinue","isFocused","canRun","canStart","resolve","onSuccess","onError","pause","continueResolve","onPause","then","onContinue","run","promiseOrValue","initialPromise","fn","error","catch","retry","retryDelay","delay","shouldRetry","onFail","continue","start"],"sources":["/Users/andrew/node_modules/@tanstack/query-core/src/retryer.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return promise\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return promise\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"module"}