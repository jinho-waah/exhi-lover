{"ast":null,"code":"// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */new Map();\n    this.#mutationId = Date.now();\n  }\n\n  #mutations;\n  #mutationId;\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    const scope = scopeFor(mutation);\n    const mutations = this.#mutations.get(scope) ?? [];\n    mutations.push(mutation);\n    this.#mutations.set(scope, mutations);\n    this.notify({\n      type: \"added\",\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    const scope = scopeFor(mutation);\n\n    if (this.#mutations.has(scope)) {\n      const mutations = this.#mutations.get(scope)?.filter(x => x !== mutation);\n\n      if (mutations) {\n        if (mutations.length === 0) {\n          this.#mutations.delete(scope);\n        } else {\n          this.#mutations.set(scope, mutations);\n        }\n      }\n    }\n\n    this.notify({\n      type: \"removed\",\n      mutation\n    });\n  }\n\n  canRun(mutation) {\n    const firstPendingMutation = this.#mutations.get(scopeFor(mutation))?.find(m => m.state.status === \"pending\");\n    return !firstPendingMutation || firstPendingMutation === mutation;\n  }\n\n  runNext(mutation) {\n    const foundMutation = this.#mutations.get(scopeFor(mutation))?.find(m => m !== mutation && m.state.isPaused);\n    return foundMutation?.continue() ?? Promise.resolve();\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return [...this.#mutations.values()].flat();\n  }\n\n  find(filters) {\n    const defaultedFilters = {\n      exact: true,\n      ...filters\n    };\n    return this.getAll().find(mutation => matchMutation(defaultedFilters, mutation));\n  }\n\n  findAll() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.getAll().filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter(x => x.state.isPaused);\n    return notifyManager.batch(() => Promise.all(pausedMutations.map(mutation => mutation.continue().catch(noop))));\n  }\n\n};\n\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id ?? String(mutation.mutationId);\n}\n\nexport { MutationCache };","map":{"version":3,"mappings":"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","names":["notifyManager","Mutation","matchMutation","noop","Subscribable","MutationCache","constructor","config","Map","Date","now","build","client","options","state","mutation","mutationCache","mutationId","defaultMutationOptions","add","scope","scopeFor","mutations","get","push","set","notify","type","remove","has","filter","x","length","delete","canRun","firstPendingMutation","find","m","status","runNext","foundMutation","isPaused","continue","Promise","resolve","clear","batch","getAll","forEach","values","flat","filters","defaultedFilters","exact","findAll","event","listeners","listener","resumePausedMutations","pausedMutations","all","map","catch","id","String"],"sources":["/Users/andrew/node_modules/@tanstack/query-core/src/mutationCache.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Map()\n    this.#mutationId = Date.now()\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    const scope = scopeFor(mutation)\n    const mutations = this.#mutations.get(scope) ?? []\n    mutations.push(mutation)\n    this.#mutations.set(scope, mutations)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    const scope = scopeFor(mutation)\n    if (this.#mutations.has(scope)) {\n      const mutations = this.#mutations\n        .get(scope)\n        ?.filter((x) => x !== mutation)\n      if (mutations) {\n        if (mutations.length === 0) {\n          this.#mutations.delete(scope)\n        } else {\n          this.#mutations.set(scope, mutations)\n        }\n      }\n    }\n\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const firstPendingMutation = this.#mutations\n      .get(scopeFor(mutation))\n      ?.find((m) => m.state.status === 'pending')\n\n    // we can run if there is no current pending mutation (start use-case)\n    // or if WE are the first pending mutation (continue use-case)\n    return !firstPendingMutation || firstPendingMutation === mutation\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const foundMutation = this.#mutations\n      .get(scopeFor(mutation))\n      ?.find((m) => m !== mutation && m.state.isPaused)\n\n    return foundMutation?.continue() ?? Promise.resolve()\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return [...this.#mutations.values()].flat()\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id ?? String(mutation.mutationId)\n}\n"]},"metadata":{},"sourceType":"module"}