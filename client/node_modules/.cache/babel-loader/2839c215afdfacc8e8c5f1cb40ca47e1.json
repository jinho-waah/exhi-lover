{"ast":null,"code":"\"use client\"; // src/HydrationBoundary.tsx\n\nimport _toConsumableArray from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from \"react\";\nimport { hydrate } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\n\nvar HydrationBoundary = function HydrationBoundary(_ref) {\n  var children = _ref.children,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {} : _ref$options,\n      state = _ref.state,\n      queryClient = _ref.queryClient;\n  var client = useQueryClient(queryClient);\n\n  var _React$useState = React.useState(),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      hydrationQueue = _React$useState2[0],\n      setHydrationQueue = _React$useState2[1];\n\n  var optionsRef = React.useRef(options);\n  optionsRef.current = options;\n  React.useMemo(function () {\n    if (state) {\n      if (typeof state !== \"object\") {\n        return;\n      }\n\n      var queryCache = client.getQueryCache();\n      var queries = state.queries || [];\n      var newQueries = [];\n      var existingQueries = [];\n\n      var _iterator = _createForOfIteratorHelper(queries),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var dehydratedQuery = _step.value;\n          var existingQuery = queryCache.get(dehydratedQuery.queryHash);\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery);\n          } else {\n            var hydrationIsNewer = dehydratedQuery.state.dataUpdatedAt > existingQuery.state.dataUpdatedAt;\n            var queryAlreadyQueued = hydrationQueue === null || hydrationQueue === void 0 ? void 0 : hydrationQueue.find(function (query) {\n              return query.queryHash === dehydratedQuery.queryHash;\n            });\n\n            if (hydrationIsNewer && (!queryAlreadyQueued || dehydratedQuery.state.dataUpdatedAt > queryAlreadyQueued.state.dataUpdatedAt)) {\n              existingQueries.push(dehydratedQuery);\n            }\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (newQueries.length > 0) {\n        hydrate(client, {\n          queries: newQueries\n        }, optionsRef.current);\n      }\n\n      if (existingQueries.length > 0) {\n        setHydrationQueue(function (prev) {\n          return prev ? [].concat(_toConsumableArray(prev), existingQueries) : existingQueries;\n        });\n      }\n    }\n  }, [client, hydrationQueue, state]);\n  React.useEffect(function () {\n    if (hydrationQueue) {\n      hydrate(client, {\n        queries: hydrationQueue\n      }, optionsRef.current);\n      setHydrationQueue(void 0);\n    }\n  }, [client, hydrationQueue]);\n  return children;\n};\n\nexport { HydrationBoundary };","map":{"version":3,"mappings":";;;;;AAGA,YAAYA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,OAAT,QAAwB,sBAAxB;AACA,SAASC,cAAT,QAA+B,0BAA/B;;AAoBO,IAAMC,oBAAoB,SAApBA,iBAAoB,OAKH;EAAA,IAJ5BC,QAI4B,QAJ5BA,QAI4B;EAAA,wBAH5BC,OAG4B;EAAA,IAH5BA,OAG4B,6BAHlB,EAGkB;EAAA,IAF5BC,KAE4B,QAF5BA,KAE4B;EAAA,IAD5BC,WAC4B,QAD5BA,WAC4B;EAC5B,IAAMC,SAASN,eAAeK,WAAf,CAAf;;EACA,sBAAkDP,gBAAlD;EAAA;EAAA,IAAOS,cAAP;EAAA,IAAuBC,iBAAvB;;EAIA,IAAMC,aAAmBX,aAAOK,OAAP,CAAzB;EACAM,WAAWC,OAAX,GAAqBP,OAArB;EAiBML,cAAQ,YAAM;IAClB,IAAIM,KAAJ,EAAW;MACT,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;QAC7B;MACF;;MAEA,IAAMO,aAAaL,OAAOM,aAAP,EAAnB;MAEA,IAAMC,UAAWT,MAA0BS,OAA1B,IAAqC,EAAtD;MAEA,IAAMC,aAAyC,EAA/C;MACA,IAAMC,kBAA8C,EAApD;;MAVS,2CAWqBF,OAXrB;MAAA;;MAAA;QAAA;UAAA,IAWEG,eAXF;UAYP,IAAMC,gBAAgBN,WAAWO,GAAX,CAAeF,gBAAgBG,SAA/B,CAAtB;;UAEA,IAAI,CAACF,aAAL,EAAoB;YAClBH,WAAWM,IAAX,CAAgBJ,eAAhB;UACF,CAFA,MAEO;YACL,IAAMK,mBACJL,gBAAgBZ,KAAhB,CAAsBkB,aAAtB,GACAL,cAAcb,KAAd,CAAoBkB,aAFtB;YAGA,IAAMC,qBAAqBhB,cAArB,aAAqBA,cAArB,uBAAqBA,eAAgBiB,IAAhB,CACzB,UAACC,KAAD;cAAA,OAAWA,MAAMN,SAAN,KAAoBH,gBAAgBG,SAA/C;YAAA,CADyB,CAA3B;;YAIA,IACEE,qBACC,CAACE,kBAAD,IACCP,gBAAgBZ,KAAhB,CAAsBkB,aAAtB,GACEC,mBAAmBnB,KAAnB,CAAyBkB,aAH7B,CADF,EAKE;cACAP,gBAAgBK,IAAhB,CAAqBJ,eAArB;YACF;UACF;QAhCO;;QAWT,oDAAuC;UAAA;QAsBvC;MAjCS;QAAA;MAAA;QAAA;MAAA;;MAmCT,IAAIF,WAAWY,MAAX,GAAoB,CAAxB,EAA2B;QAGzB3B,QAAQO,MAAR,EAAgB;UAAEO,SAASC;QAAX,CAAhB,EAAyCL,WAAWC,OAApD;MACF;;MACA,IAAIK,gBAAgBW,MAAhB,GAAyB,CAA7B,EAAgC;QAC9BlB,kBAAkB,UAACmB,IAAD;UAAA,OAChBA,oCAAWA,IAAX,GAAoBZ,eAApB,IAAuCA,eADvB;QAAA,CAAlB;MAGF;IACF;EACF,CA/CM,EA+CH,CAACT,MAAD,EAASC,cAAT,EAAyBH,KAAzB,CA/CG;EAiDAN,gBAAU,YAAM;IACpB,IAAIS,cAAJ,EAAoB;MAClBR,QAAQO,MAAR,EAAgB;QAAEO,SAASN;MAAX,CAAhB,EAA6CE,WAAWC,OAAxD;MACAF,kBAAkB,MAAlB;IACF;EACF,CALM,EAKH,CAACF,MAAD,EAASC,cAAT,CALG;EAON,OAAOL,QAAP;AACF,CAtFO","names":["React","hydrate","useQueryClient","HydrationBoundary","children","options","state","queryClient","client","hydrationQueue","setHydrationQueue","optionsRef","current","queryCache","getQueryCache","queries","newQueries","existingQueries","dehydratedQuery","existingQuery","get","queryHash","push","hydrationIsNewer","dataUpdatedAt","queryAlreadyQueued","find","query","length","prev"],"sources":["/Users/andrew/node_modules/@tanstack/react-query/src/HydrationBoundary.tsx"],"sourcesContent":["/* eslint-disable react-compiler/react-compiler */\n\n'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n  const [hydrationQueue, setHydrationQueue] = React.useState<\n    DehydratedState['queries'] | undefined\n  >()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it _must_\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  React.useMemo(() => {\n    if (state) {\n      if (typeof state !== 'object') {\n        return\n      }\n\n      const queryCache = client.getQueryCache()\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const queries = (state as DehydratedState).queries || []\n\n      const newQueries: DehydratedState['queries'] = []\n      const existingQueries: DehydratedState['queries'] = []\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery)\n        } else {\n          const hydrationIsNewer =\n            dehydratedQuery.state.dataUpdatedAt >\n            existingQuery.state.dataUpdatedAt\n          const queryAlreadyQueued = hydrationQueue?.find(\n            (query) => query.queryHash === dehydratedQuery.queryHash,\n          )\n\n          if (\n            hydrationIsNewer &&\n            (!queryAlreadyQueued ||\n              dehydratedQuery.state.dataUpdatedAt >\n                queryAlreadyQueued.state.dataUpdatedAt)\n          ) {\n            existingQueries.push(dehydratedQuery)\n          }\n        }\n      }\n\n      if (newQueries.length > 0) {\n        // It's actually fine to call this with queries/state that already exists\n        // in the cache, or is older. hydrate() is idempotent for queries.\n        hydrate(client, { queries: newQueries }, optionsRef.current)\n      }\n      if (existingQueries.length > 0) {\n        setHydrationQueue((prev) =>\n          prev ? [...prev, ...existingQueries] : existingQueries,\n        )\n      }\n    }\n  }, [client, hydrationQueue, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n      setHydrationQueue(undefined)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n"]},"metadata":{},"sourceType":"module"}