{"ast":null,"code":"// src/suspense.ts\nvar defaultThrowOnError = function defaultThrowOnError(_error, query) {\n  return query.state.data === void 0;\n};\n\nvar ensureSuspenseTimers = function ensureSuspenseTimers(defaultedOptions) {\n  if (defaultedOptions.suspense) {\n    if (typeof defaultedOptions.staleTime !== \"number\") {\n      defaultedOptions.staleTime = 1e3;\n    }\n\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\n\nvar willFetch = function willFetch(result, isRestoring) {\n  return result.isLoading && result.isFetching && !isRestoring;\n};\n\nvar shouldSuspend = function shouldSuspend(defaultedOptions, result) {\n  return (defaultedOptions === null || defaultedOptions === void 0 ? void 0 : defaultedOptions.suspense) && result.isPending;\n};\n\nvar fetchOptimistic = function fetchOptimistic(defaultedOptions, observer, errorResetBoundary) {\n  return observer.fetchOptimistic(defaultedOptions).catch(function () {\n    errorResetBoundary.clearReset();\n  });\n};\n\nexport { defaultThrowOnError, ensureSuspenseTimers, fetchOptimistic, shouldSuspend, willFetch };","map":{"version":3,"mappings":";AAUO,IAAMA,sBAAsB,SAAtBA,mBAAsB,CAMjCC,MANiC,EAOjCC,KAPiC;EAAA,OAQ9BA,MAAMC,KAAN,CAAYC,IAAZ,KAAqB,MARS;AAAA,CAA5B;;AAUA,IAAMC,uBAAuB,SAAvBA,oBAAuB,CAClCC,gBADkC,EAE/B;EACH,IAAIA,iBAAiBC,QAArB,EAA+B;IAG7B,IAAI,OAAOD,iBAAiBE,SAAxB,KAAsC,QAA1C,EAAoD;MAClDF,iBAAiBE,SAAjB,GAA6B,GAA7B;IACF;;IACA,IAAI,OAAOF,iBAAiBG,MAAxB,KAAmC,QAAvC,EAAiD;MAC/CH,iBAAiBG,MAAjB,GAA0BC,KAAKC,GAAL,CAASL,iBAAiBG,MAA1B,EAAkC,GAAlC,CAA1B;IACF;EACF;AACF,CAbO;;AAeA,IAAMG,YAAY,SAAZA,SAAY,CACvBC,MADuB,EAEvBC,WAFuB;EAAA,OAGpBD,OAAOE,SAAP,IAAoBF,OAAOG,UAA3B,IAAyC,CAACF,WAHtB;AAAA,CAAlB;;AAKA,IAAMG,gBAAgB,SAAhBA,aAAgB,CAC3BX,gBAD2B,EAI3BO,MAJ2B;EAAA,OAKxB,sFAAkBN,QAAlB,KAA8BM,OAAOK,SALb;AAAA,CAAtB;;AAOA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAO7Bb,gBAP6B,EAc7Bc,QAd6B,EAe7BC,kBAf6B;EAAA,OAiB7BD,SAASD,eAAT,CAAyBb,gBAAzB,EAA2CgB,KAA3C,CAAiD,YAAM;IACrDD,mBAAmBE,UAAnB;EACD,CAFD,CAjB6B;AAAA,CAAxB","names":["defaultThrowOnError","_error","query","state","data","ensureSuspenseTimers","defaultedOptions","suspense","staleTime","gcTime","Math","max","willFetch","result","isRestoring","isLoading","isFetching","shouldSuspend","isPending","fetchOptimistic","observer","errorResetBoundary","catch","clearReset"],"sources":["/Users/andrew/node_modules/@tanstack/react-query/src/suspense.ts"],"sourcesContent":["import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n"]},"metadata":{},"sourceType":"module"}