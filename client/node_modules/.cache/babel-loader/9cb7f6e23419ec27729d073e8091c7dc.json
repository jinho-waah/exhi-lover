{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { replaceInvalidDateByNull, splitFormatIntoSections, addPositionPropertiesToSections, createDateStrForInputFromSections, getSectionOrder } from '@mui/x-date-pickers/internals';\nimport { splitDateRangeSections, removeLastSeparator } from './date-fields-utils';\nexport const rangeValueManager = {\n  emptyValue: [null, null],\n  getTodayValue: utils => [utils.date(), utils.date()],\n  cleanValue: (utils, value) => value.map(date => replaceInvalidDateByNull(utils, date)),\n  areValuesEqual: (utils, a, b) => utils.isEqual(a[0], b[0]) && utils.isEqual(a[1], b[1]),\n  isSameError: (a, b) => b !== null && a[1] === b[1] && a[0] === b[0],\n  defaultErrorState: [null, null]\n};\nexport const rangeFieldValueManager = {\n  updateReferenceValue: (utils, value, prevReferenceValue) => {\n    const shouldKeepStartDate = value[0] != null && utils.isValid(value[0]);\n    const shouldKeepEndDate = value[1] != null && utils.isValid(value[1]);\n\n    if (!shouldKeepStartDate && !shouldKeepEndDate) {\n      return prevReferenceValue;\n    }\n\n    if (shouldKeepStartDate && shouldKeepEndDate) {\n      return value;\n    }\n\n    if (shouldKeepStartDate) {\n      return [value[0], prevReferenceValue[0]];\n    }\n\n    return [prevReferenceValue[1], value[1]];\n  },\n  getSectionsFromValue: (utils, localeText, prevSections, _ref, format) => {\n    let [start, end] = _ref;\n    const prevDateRangeSections = prevSections == null ? {\n      startDate: null,\n      endDate: null\n    } : splitDateRangeSections(prevSections);\n\n    const getSections = (newDate, prevDateSections, position) => {\n      const shouldReUsePrevDateSections = !utils.isValid(newDate) && !!prevDateSections;\n\n      if (shouldReUsePrevDateSections) {\n        return prevDateSections;\n      }\n\n      const sections = splitFormatIntoSections(utils, localeText, format, newDate);\n      return sections.map((section, sectionIndex) => {\n        if (sectionIndex === sections.length - 1 && position === 'start') {\n          return _extends({}, section, {\n            dateName: position,\n            endSeparator: `${section.endSeparator}\\u2069 – \\u2066`\n          });\n        }\n\n        return _extends({}, section, {\n          dateName: position\n        });\n      });\n    };\n\n    return addPositionPropertiesToSections([...getSections(start, prevDateRangeSections.startDate, 'start'), ...getSections(end, prevDateRangeSections.endDate, 'end')]);\n  },\n  getValueStrFromSections: sections => {\n    const dateRangeSections = splitDateRangeSections(sections);\n    return createDateStrForInputFromSections([...dateRangeSections.startDate, ...dateRangeSections.endDate]);\n  },\n  getActiveDateSections: (sections, activeSection) => {\n    const index = activeSection.dateName === 'start' ? 0 : 1;\n    const dateRangeSections = splitDateRangeSections(sections);\n    return index === 0 ? removeLastSeparator(dateRangeSections.startDate) : dateRangeSections.endDate;\n  },\n  parseValueStr: (valueStr, referenceValue, parseDate) => {\n    // TODO: Improve because it would not work if the date format has `–` as a separator.\n    const [startStr, endStr] = valueStr.split('–');\n    return [startStr, endStr].map((dateStr, index) => {\n      if (dateStr == null) {\n        return null;\n      }\n\n      return parseDate(dateStr.trim(), referenceValue[index]);\n    });\n  },\n  getActiveDateManager: (utils, state, activeSection) => {\n    const index = activeSection.dateName === 'start' ? 0 : 1;\n\n    const updateDateInRange = (newDate, prevDateRange) => index === 0 ? [newDate, prevDateRange[1]] : [prevDateRange[0], newDate];\n\n    return {\n      activeDate: state.value[index],\n      referenceActiveDate: state.referenceValue[index],\n      getNewValueFromNewActiveDate: newActiveDate => ({\n        value: updateDateInRange(newActiveDate, state.value),\n        referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : updateDateInRange(newActiveDate, state.referenceValue)\n      })\n    };\n  },\n  hasError: error => error[0] != null || error[1] != null,\n  getSectionOrder: (utils, localeText, format, isRTL) => {\n    const splitedFormat = splitFormatIntoSections(utils, localeText, format, null);\n    return getSectionOrder([...splitedFormat.slice(0, splitedFormat.length - 1), _extends({}, splitedFormat[splitedFormat.length - 1], {\n      endSeparator: ' – '\n    }), ...splitedFormat], isRTL);\n  }\n};","map":{"version":3,"names":["_extends","replaceInvalidDateByNull","splitFormatIntoSections","addPositionPropertiesToSections","createDateStrForInputFromSections","getSectionOrder","splitDateRangeSections","removeLastSeparator","rangeValueManager","emptyValue","getTodayValue","utils","date","cleanValue","value","map","areValuesEqual","a","b","isEqual","isSameError","defaultErrorState","rangeFieldValueManager","updateReferenceValue","prevReferenceValue","shouldKeepStartDate","isValid","shouldKeepEndDate","getSectionsFromValue","localeText","prevSections","format","start","end","prevDateRangeSections","startDate","endDate","getSections","newDate","prevDateSections","position","shouldReUsePrevDateSections","sections","section","sectionIndex","length","dateName","endSeparator","getValueStrFromSections","dateRangeSections","getActiveDateSections","activeSection","index","parseValueStr","valueStr","referenceValue","parseDate","startStr","endStr","split","dateStr","trim","getActiveDateManager","state","updateDateInRange","prevDateRange","activeDate","referenceActiveDate","getNewValueFromNewActiveDate","newActiveDate","hasError","error","isRTL","splitedFormat","slice"],"sources":["/Users/andrew/Desktop/exhi/exhi/client/node_modules/@mui/x-date-pickers-pro/internal/utils/valueManagers.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { replaceInvalidDateByNull, splitFormatIntoSections, addPositionPropertiesToSections, createDateStrForInputFromSections, getSectionOrder } from '@mui/x-date-pickers/internals';\nimport { splitDateRangeSections, removeLastSeparator } from './date-fields-utils';\nexport const rangeValueManager = {\n  emptyValue: [null, null],\n  getTodayValue: utils => [utils.date(), utils.date()],\n  cleanValue: (utils, value) => value.map(date => replaceInvalidDateByNull(utils, date)),\n  areValuesEqual: (utils, a, b) => utils.isEqual(a[0], b[0]) && utils.isEqual(a[1], b[1]),\n  isSameError: (a, b) => b !== null && a[1] === b[1] && a[0] === b[0],\n  defaultErrorState: [null, null]\n};\nexport const rangeFieldValueManager = {\n  updateReferenceValue: (utils, value, prevReferenceValue) => {\n    const shouldKeepStartDate = value[0] != null && utils.isValid(value[0]);\n    const shouldKeepEndDate = value[1] != null && utils.isValid(value[1]);\n    if (!shouldKeepStartDate && !shouldKeepEndDate) {\n      return prevReferenceValue;\n    }\n    if (shouldKeepStartDate && shouldKeepEndDate) {\n      return value;\n    }\n    if (shouldKeepStartDate) {\n      return [value[0], prevReferenceValue[0]];\n    }\n    return [prevReferenceValue[1], value[1]];\n  },\n  getSectionsFromValue: (utils, localeText, prevSections, [start, end], format) => {\n    const prevDateRangeSections = prevSections == null ? {\n      startDate: null,\n      endDate: null\n    } : splitDateRangeSections(prevSections);\n    const getSections = (newDate, prevDateSections, position) => {\n      const shouldReUsePrevDateSections = !utils.isValid(newDate) && !!prevDateSections;\n      if (shouldReUsePrevDateSections) {\n        return prevDateSections;\n      }\n      const sections = splitFormatIntoSections(utils, localeText, format, newDate);\n      return sections.map((section, sectionIndex) => {\n        if (sectionIndex === sections.length - 1 && position === 'start') {\n          return _extends({}, section, {\n            dateName: position,\n            endSeparator: `${section.endSeparator}\\u2069 – \\u2066`\n          });\n        }\n        return _extends({}, section, {\n          dateName: position\n        });\n      });\n    };\n    return addPositionPropertiesToSections([...getSections(start, prevDateRangeSections.startDate, 'start'), ...getSections(end, prevDateRangeSections.endDate, 'end')]);\n  },\n  getValueStrFromSections: sections => {\n    const dateRangeSections = splitDateRangeSections(sections);\n    return createDateStrForInputFromSections([...dateRangeSections.startDate, ...dateRangeSections.endDate]);\n  },\n  getActiveDateSections: (sections, activeSection) => {\n    const index = activeSection.dateName === 'start' ? 0 : 1;\n    const dateRangeSections = splitDateRangeSections(sections);\n    return index === 0 ? removeLastSeparator(dateRangeSections.startDate) : dateRangeSections.endDate;\n  },\n  parseValueStr: (valueStr, referenceValue, parseDate) => {\n    // TODO: Improve because it would not work if the date format has `–` as a separator.\n    const [startStr, endStr] = valueStr.split('–');\n    return [startStr, endStr].map((dateStr, index) => {\n      if (dateStr == null) {\n        return null;\n      }\n      return parseDate(dateStr.trim(), referenceValue[index]);\n    });\n  },\n  getActiveDateManager: (utils, state, activeSection) => {\n    const index = activeSection.dateName === 'start' ? 0 : 1;\n    const updateDateInRange = (newDate, prevDateRange) => index === 0 ? [newDate, prevDateRange[1]] : [prevDateRange[0], newDate];\n    return {\n      activeDate: state.value[index],\n      referenceActiveDate: state.referenceValue[index],\n      getNewValueFromNewActiveDate: newActiveDate => ({\n        value: updateDateInRange(newActiveDate, state.value),\n        referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : updateDateInRange(newActiveDate, state.referenceValue)\n      })\n    };\n  },\n  hasError: error => error[0] != null || error[1] != null,\n  getSectionOrder: (utils, localeText, format, isRTL) => {\n    const splitedFormat = splitFormatIntoSections(utils, localeText, format, null);\n    return getSectionOrder([...splitedFormat.slice(0, splitedFormat.length - 1), _extends({}, splitedFormat[splitedFormat.length - 1], {\n      endSeparator: ' – '\n    }), ...splitedFormat], isRTL);\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}