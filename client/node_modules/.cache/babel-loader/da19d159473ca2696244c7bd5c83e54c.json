{"ast":null,"code":"import _objectSpread from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classPrivateMethodInitSpec from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\n\nvar _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _executeFetch, _updateStaleTimeout, _computeRefetchInterval, _updateRefetchInterval, _updateTimers, _clearStaleTimeout, _clearRefetchInterval, _updateQuery, _notify;\n\n// src/queryObserver.ts\nimport { isServer, isValidTimeout, noop, replaceData, resolveEnabled, resolveStaleTime, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { fetchState } from \"./query.js\";\nvar QueryObserver = (_client = /*#__PURE__*/new WeakMap(), _currentQuery = /*#__PURE__*/new WeakMap(), _currentQueryInitialState = /*#__PURE__*/new WeakMap(), _currentResult = /*#__PURE__*/new WeakMap(), _currentResultState = /*#__PURE__*/new WeakMap(), _currentResultOptions = /*#__PURE__*/new WeakMap(), _selectError = /*#__PURE__*/new WeakMap(), _selectFn = /*#__PURE__*/new WeakMap(), _selectResult = /*#__PURE__*/new WeakMap(), _lastQueryWithDefinedData = /*#__PURE__*/new WeakMap(), _staleTimeoutId = /*#__PURE__*/new WeakMap(), _refetchIntervalId = /*#__PURE__*/new WeakMap(), _currentRefetchInterval = /*#__PURE__*/new WeakMap(), _trackedProps = /*#__PURE__*/new WeakMap(), _executeFetch = /*#__PURE__*/new WeakSet(), _updateStaleTimeout = /*#__PURE__*/new WeakSet(), _computeRefetchInterval = /*#__PURE__*/new WeakSet(), _updateRefetchInterval = /*#__PURE__*/new WeakSet(), _updateTimers = /*#__PURE__*/new WeakSet(), _clearStaleTimeout = /*#__PURE__*/new WeakSet(), _clearRefetchInterval = /*#__PURE__*/new WeakSet(), _updateQuery = /*#__PURE__*/new WeakSet(), _notify = /*#__PURE__*/new WeakSet(), /*#__PURE__*/function (_Subscribable) {\n  _inherits(QueryObserver, _Subscribable);\n\n  var _super = _createSuper(QueryObserver);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _classCallCheck(this, QueryObserver);\n\n    _this = _super.call(this);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _notify);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateQuery);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _clearRefetchInterval);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _clearStaleTimeout);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateTimers);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateRefetchInterval);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _computeRefetchInterval);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _updateStaleTimeout);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _executeFetch);\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _client, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentQuery, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentQueryInitialState, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentResult, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentResultState, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentResultOptions, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _selectError, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _selectFn, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _selectResult, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _lastQueryWithDefinedData, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _staleTimeoutId, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _refetchIntervalId, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _currentRefetchInterval, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _trackedProps, {\n      writable: true,\n      value: /* @__PURE__ */new Set()\n    });\n\n    _this.options = options;\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _client, client);\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _selectError, null);\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  _createClass(QueryObserver, [{\n    key: \"bindMethods\",\n    value: function bindMethods() {\n      this.refetch = this.refetch.bind(this);\n    }\n  }, {\n    key: \"onSubscribe\",\n    value: function onSubscribe() {\n      if (this.listeners.size === 1) {\n        _classPrivateFieldGet(this, _currentQuery).addObserver(this);\n\n        if (shouldFetchOnMount(_classPrivateFieldGet(this, _currentQuery), this.options)) {\n          _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this);\n        } else {\n          this.updateResult();\n        }\n\n        _classPrivateMethodGet(this, _updateTimers, _updateTimers2).call(this);\n      }\n    }\n  }, {\n    key: \"onUnsubscribe\",\n    value: function onUnsubscribe() {\n      if (!this.hasListeners()) {\n        this.destroy();\n      }\n    }\n  }, {\n    key: \"shouldFetchOnReconnect\",\n    value: function shouldFetchOnReconnect() {\n      return shouldFetchOn(_classPrivateFieldGet(this, _currentQuery), this.options, this.options.refetchOnReconnect);\n    }\n  }, {\n    key: \"shouldFetchOnWindowFocus\",\n    value: function shouldFetchOnWindowFocus() {\n      return shouldFetchOn(_classPrivateFieldGet(this, _currentQuery), this.options, this.options.refetchOnWindowFocus);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.listeners = /* @__PURE__ */new Set();\n\n      _classPrivateMethodGet(this, _clearStaleTimeout, _clearStaleTimeout2).call(this);\n\n      _classPrivateMethodGet(this, _clearRefetchInterval, _clearRefetchInterval2).call(this);\n\n      _classPrivateFieldGet(this, _currentQuery).removeObserver(this);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, notifyOptions) {\n      var prevOptions = this.options;\n\n      var prevQuery = _classPrivateFieldGet(this, _currentQuery);\n\n      this.options = _classPrivateFieldGet(this, _client).defaultQueryOptions(options);\n\n      if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) !== \"boolean\") {\n        throw new Error(\"Expected enabled to be a boolean or a callback that returns a boolean\");\n      }\n\n      _classPrivateMethodGet(this, _updateQuery, _updateQuery2).call(this);\n\n      _classPrivateFieldGet(this, _currentQuery).setOptions(this.options);\n\n      if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n        _classPrivateFieldGet(this, _client).getQueryCache().notify({\n          type: \"observerOptionsUpdated\",\n          query: _classPrivateFieldGet(this, _currentQuery),\n          observer: this\n        });\n      }\n\n      var mounted = this.hasListeners();\n\n      if (mounted && shouldFetchOptionally(_classPrivateFieldGet(this, _currentQuery), prevQuery, this.options, prevOptions)) {\n        _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this);\n      }\n\n      this.updateResult(notifyOptions);\n\n      if (mounted && (_classPrivateFieldGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, _classPrivateFieldGet(this, _currentQuery)))) {\n        _classPrivateMethodGet(this, _updateStaleTimeout, _updateStaleTimeout2).call(this);\n      }\n\n      var nextRefetchInterval = _classPrivateMethodGet(this, _computeRefetchInterval, _computeRefetchInterval2).call(this);\n\n      if (mounted && (_classPrivateFieldGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(this, _currentQuery)) || nextRefetchInterval !== _classPrivateFieldGet(this, _currentRefetchInterval))) {\n        _classPrivateMethodGet(this, _updateRefetchInterval, _updateRefetchInterval2).call(this, nextRefetchInterval);\n      }\n    }\n  }, {\n    key: \"getOptimisticResult\",\n    value: function getOptimisticResult(options) {\n      var query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), options);\n\n      var result = this.createResult(query, options);\n\n      if (shouldAssignObserverCurrentProperties(this, result)) {\n        _classPrivateFieldSet(this, _currentResult, result);\n\n        _classPrivateFieldSet(this, _currentResultOptions, this.options);\n\n        _classPrivateFieldSet(this, _currentResultState, _classPrivateFieldGet(this, _currentQuery).state);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getCurrentResult\",\n    value: function getCurrentResult() {\n      return _classPrivateFieldGet(this, _currentResult);\n    }\n  }, {\n    key: \"trackResult\",\n    value: function trackResult(result, onPropTracked) {\n      var _this2 = this;\n\n      var trackedResult = {};\n      Object.keys(result).forEach(function (key) {\n        Object.defineProperty(trackedResult, key, {\n          configurable: false,\n          enumerable: true,\n          get: function get() {\n            _this2.trackProp(key);\n\n            onPropTracked === null || onPropTracked === void 0 ? void 0 : onPropTracked(key);\n            return result[key];\n          }\n        });\n      });\n      return trackedResult;\n    }\n  }, {\n    key: \"trackProp\",\n    value: function trackProp(key) {\n      _classPrivateFieldGet(this, _trackedProps).add(key);\n    }\n  }, {\n    key: \"getCurrentQuery\",\n    value: function getCurrentQuery() {\n      return _classPrivateFieldGet(this, _currentQuery);\n    }\n  }, {\n    key: \"refetch\",\n    value: function refetch() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          options = Object.assign({}, _ref);\n\n      return this.fetch(_objectSpread({}, options));\n    }\n  }, {\n    key: \"fetchOptimistic\",\n    value: function fetchOptimistic(options) {\n      var _this3 = this;\n\n      var defaultedOptions = _classPrivateFieldGet(this, _client).defaultQueryOptions(options);\n\n      var query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), defaultedOptions);\n\n      query.isFetchingOptimistic = true;\n      return query.fetch().then(function () {\n        return _this3.createResult(query, defaultedOptions);\n      });\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(fetchOptions) {\n      var _fetchOptions$cancelR,\n          _this4 = this;\n\n      return _classPrivateMethodGet(this, _executeFetch, _executeFetch2).call(this, _objectSpread(_objectSpread({}, fetchOptions), {}, {\n        cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) !== null && _fetchOptions$cancelR !== void 0 ? _fetchOptions$cancelR : true\n      })).then(function () {\n        _this4.updateResult();\n\n        return _classPrivateFieldGet(_this4, _currentResult);\n      });\n    }\n  }, {\n    key: \"createResult\",\n    value: function createResult(query, options) {\n      var prevQuery = _classPrivateFieldGet(this, _currentQuery);\n\n      var prevOptions = this.options;\n\n      var prevResult = _classPrivateFieldGet(this, _currentResult);\n\n      var prevResultState = _classPrivateFieldGet(this, _currentResultState);\n\n      var prevResultOptions = _classPrivateFieldGet(this, _currentResultOptions);\n\n      var queryChange = query !== prevQuery;\n      var queryInitialState = queryChange ? query.state : _classPrivateFieldGet(this, _currentQueryInitialState);\n      var state = query.state;\n\n      var newState = _objectSpread({}, state);\n\n      var isPlaceholderData = false;\n      var data;\n\n      if (options._optimisticResults) {\n        var mounted = this.hasListeners();\n        var fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n        var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n        if (fetchOnMount || fetchOptionally) {\n          newState = _objectSpread(_objectSpread({}, newState), fetchState(state.data, query.options));\n        }\n\n        if (options._optimisticResults === \"isRestoring\") {\n          newState.fetchStatus = \"idle\";\n        }\n      }\n\n      var _newState = newState,\n          error = _newState.error,\n          errorUpdatedAt = _newState.errorUpdatedAt,\n          status = _newState.status;\n\n      if (options.select && newState.data !== void 0) {\n        if (prevResult && newState.data === (prevResultState === null || prevResultState === void 0 ? void 0 : prevResultState.data) && options.select === _classPrivateFieldGet(this, _selectFn)) {\n          data = _classPrivateFieldGet(this, _selectResult);\n        } else {\n          try {\n            _classPrivateFieldSet(this, _selectFn, options.select);\n\n            data = options.select(newState.data);\n            data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, data, options);\n\n            _classPrivateFieldSet(this, _selectResult, data);\n\n            _classPrivateFieldSet(this, _selectError, null);\n          } catch (selectError) {\n            _classPrivateFieldSet(this, _selectError, selectError);\n          }\n        }\n      } else {\n        data = newState.data;\n      }\n\n      if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n        var placeholderData;\n\n        if (prevResult !== null && prevResult !== void 0 && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions === null || prevResultOptions === void 0 ? void 0 : prevResultOptions.placeholderData)) {\n          placeholderData = prevResult.data;\n        } else {\n          var _classPrivateFieldGet2;\n\n          placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData((_classPrivateFieldGet2 = _classPrivateFieldGet(this, _lastQueryWithDefinedData)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.state.data, _classPrivateFieldGet(this, _lastQueryWithDefinedData)) : options.placeholderData;\n\n          if (options.select && placeholderData !== void 0) {\n            try {\n              placeholderData = options.select(placeholderData);\n\n              _classPrivateFieldSet(this, _selectError, null);\n            } catch (selectError) {\n              _classPrivateFieldSet(this, _selectError, selectError);\n            }\n          }\n        }\n\n        if (placeholderData !== void 0) {\n          status = \"success\";\n          data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, placeholderData, options);\n          isPlaceholderData = true;\n        }\n      }\n\n      if (_classPrivateFieldGet(this, _selectError)) {\n        error = _classPrivateFieldGet(this, _selectError);\n        data = _classPrivateFieldGet(this, _selectResult);\n        errorUpdatedAt = Date.now();\n        status = \"error\";\n      }\n\n      var isFetching = newState.fetchStatus === \"fetching\";\n      var isPending = status === \"pending\";\n      var isError = status === \"error\";\n      var isLoading = isPending && isFetching;\n      var hasData = data !== void 0;\n      var result = {\n        status: status,\n        fetchStatus: newState.fetchStatus,\n        isPending: isPending,\n        isSuccess: status === \"success\",\n        isError: isError,\n        isInitialLoading: isLoading,\n        isLoading: isLoading,\n        data: data,\n        dataUpdatedAt: newState.dataUpdatedAt,\n        error: error,\n        errorUpdatedAt: errorUpdatedAt,\n        failureCount: newState.fetchFailureCount,\n        failureReason: newState.fetchFailureReason,\n        errorUpdateCount: newState.errorUpdateCount,\n        isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n        isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n        isFetching: isFetching,\n        isRefetching: isFetching && !isPending,\n        isLoadingError: isError && !hasData,\n        isPaused: newState.fetchStatus === \"paused\",\n        isPlaceholderData: isPlaceholderData,\n        isRefetchError: isError && hasData,\n        isStale: isStale(query, options),\n        refetch: this.refetch\n      };\n      return result;\n    }\n  }, {\n    key: \"updateResult\",\n    value: function updateResult(notifyOptions) {\n      var _this5 = this;\n\n      var prevResult = _classPrivateFieldGet(this, _currentResult);\n\n      var nextResult = this.createResult(_classPrivateFieldGet(this, _currentQuery), this.options);\n\n      _classPrivateFieldSet(this, _currentResultState, _classPrivateFieldGet(this, _currentQuery).state);\n\n      _classPrivateFieldSet(this, _currentResultOptions, this.options);\n\n      if (_classPrivateFieldGet(this, _currentResultState).data !== void 0) {\n        _classPrivateFieldSet(this, _lastQueryWithDefinedData, _classPrivateFieldGet(this, _currentQuery));\n      }\n\n      if (shallowEqualObjects(nextResult, prevResult)) {\n        return;\n      }\n\n      _classPrivateFieldSet(this, _currentResult, nextResult);\n\n      var defaultNotifyOptions = {};\n\n      var shouldNotifyListeners = function shouldNotifyListeners() {\n        if (!prevResult) {\n          return true;\n        }\n\n        var notifyOnChangeProps = _this5.options.notifyOnChangeProps;\n        var notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n\n        if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !_classPrivateFieldGet(_this5, _trackedProps).size) {\n          return true;\n        }\n\n        var includedProps = new Set(notifyOnChangePropsValue !== null && notifyOnChangePropsValue !== void 0 ? notifyOnChangePropsValue : _classPrivateFieldGet(_this5, _trackedProps));\n\n        if (_this5.options.throwOnError) {\n          includedProps.add(\"error\");\n        }\n\n        return Object.keys(_classPrivateFieldGet(_this5, _currentResult)).some(function (key) {\n          var typedKey = key;\n          var changed = _classPrivateFieldGet(_this5, _currentResult)[typedKey] !== prevResult[typedKey];\n          return changed && includedProps.has(typedKey);\n        });\n      };\n\n      if ((notifyOptions === null || notifyOptions === void 0 ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n        defaultNotifyOptions.listeners = true;\n      }\n\n      _classPrivateMethodGet(this, _notify, _notify2).call(this, _objectSpread(_objectSpread({}, defaultNotifyOptions), notifyOptions));\n    }\n  }, {\n    key: \"onQueryUpdate\",\n    value: function onQueryUpdate() {\n      this.updateResult();\n\n      if (this.hasListeners()) {\n        _classPrivateMethodGet(this, _updateTimers, _updateTimers2).call(this);\n      }\n    }\n  }]);\n\n  return QueryObserver;\n}(Subscribable));\n\nfunction _executeFetch2(fetchOptions) {\n  _classPrivateMethodGet(this, _updateQuery, _updateQuery2).call(this);\n\n  var promise = _classPrivateFieldGet(this, _currentQuery).fetch(this.options, fetchOptions);\n\n  if (!(fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.throwOnError)) {\n    promise = promise.catch(noop);\n  }\n\n  return promise;\n}\n\nfunction _updateStaleTimeout2() {\n  var _this6 = this;\n\n  _classPrivateMethodGet(this, _clearStaleTimeout, _clearStaleTimeout2).call(this);\n\n  var staleTime = resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(this, _currentQuery));\n\n  if (isServer || _classPrivateFieldGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {\n    return;\n  }\n\n  var time = timeUntilStale(_classPrivateFieldGet(this, _currentResult).dataUpdatedAt, staleTime);\n  var timeout = time + 1;\n\n  _classPrivateFieldSet(this, _staleTimeoutId, setTimeout(function () {\n    if (!_classPrivateFieldGet(_this6, _currentResult).isStale) {\n      _this6.updateResult();\n    }\n  }, timeout));\n}\n\nfunction _computeRefetchInterval2() {\n  var _ref2;\n\n  return (_ref2 = typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(_classPrivateFieldGet(this, _currentQuery)) : this.options.refetchInterval) !== null && _ref2 !== void 0 ? _ref2 : false;\n}\n\nfunction _updateRefetchInterval2(nextInterval) {\n  var _this7 = this;\n\n  _classPrivateMethodGet(this, _clearRefetchInterval, _clearRefetchInterval2).call(this);\n\n  _classPrivateFieldSet(this, _currentRefetchInterval, nextInterval);\n\n  if (isServer || resolveEnabled(this.options.enabled, _classPrivateFieldGet(this, _currentQuery)) === false || !isValidTimeout(_classPrivateFieldGet(this, _currentRefetchInterval)) || _classPrivateFieldGet(this, _currentRefetchInterval) === 0) {\n    return;\n  }\n\n  _classPrivateFieldSet(this, _refetchIntervalId, setInterval(function () {\n    if (_this7.options.refetchIntervalInBackground || focusManager.isFocused()) {\n      _classPrivateMethodGet(_this7, _executeFetch, _executeFetch2).call(_this7);\n    }\n  }, _classPrivateFieldGet(this, _currentRefetchInterval)));\n}\n\nfunction _updateTimers2() {\n  _classPrivateMethodGet(this, _updateStaleTimeout, _updateStaleTimeout2).call(this);\n\n  _classPrivateMethodGet(this, _updateRefetchInterval, _updateRefetchInterval2).call(this, _classPrivateMethodGet(this, _computeRefetchInterval, _computeRefetchInterval2).call(this));\n}\n\nfunction _clearStaleTimeout2() {\n  if (_classPrivateFieldGet(this, _staleTimeoutId)) {\n    clearTimeout(_classPrivateFieldGet(this, _staleTimeoutId));\n\n    _classPrivateFieldSet(this, _staleTimeoutId, void 0);\n  }\n}\n\nfunction _clearRefetchInterval2() {\n  if (_classPrivateFieldGet(this, _refetchIntervalId)) {\n    clearInterval(_classPrivateFieldGet(this, _refetchIntervalId));\n\n    _classPrivateFieldSet(this, _refetchIntervalId, void 0);\n  }\n}\n\nfunction _updateQuery2() {\n  var query = _classPrivateFieldGet(this, _client).getQueryCache().build(_classPrivateFieldGet(this, _client), this.options);\n\n  if (query === _classPrivateFieldGet(this, _currentQuery)) {\n    return;\n  }\n\n  var prevQuery = _classPrivateFieldGet(this, _currentQuery);\n\n  _classPrivateFieldSet(this, _currentQuery, query);\n\n  _classPrivateFieldSet(this, _currentQueryInitialState, query.state);\n\n  if (this.hasListeners()) {\n    prevQuery === null || prevQuery === void 0 ? void 0 : prevQuery.removeObserver(this);\n    query.addObserver(this);\n  }\n}\n\nfunction _notify2(notifyOptions) {\n  var _this8 = this;\n\n  notifyManager.batch(function () {\n    if (notifyOptions.listeners) {\n      _this8.listeners.forEach(function (listener) {\n        listener(_classPrivateFieldGet(_this8, _currentResult));\n      });\n    }\n\n    _classPrivateFieldGet(_this8, _client).getQueryCache().notify({\n      query: _classPrivateFieldGet(_this8, _currentQuery),\n      type: \"observerResultsUpdated\"\n    });\n  });\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    var value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport { QueryObserver };","map":{"version":3,"mappings":"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","names":["isServer","isValidTimeout","noop","replaceData","resolveEnabled","resolveStaleTime","shallowEqualObjects","timeUntilStale","notifyManager","focusManager","Subscribable","fetchState","QueryObserver","client","options","Set","bindMethods","setOptions","refetch","bind","listeners","size","addObserver","shouldFetchOnMount","updateResult","hasListeners","destroy","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","enabled","Error","_defaulted","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","staleTime","nextRefetchInterval","build","result","createResult","shouldAssignObserverCurrentProperties","state","onPropTracked","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","trackProp","add","fetch","defaultedOptions","isFetchingOptimistic","then","fetchOptions","cancelRefetch","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","newState","isPlaceholderData","data","_optimisticResults","fetchOnMount","fetchOptionally","fetchStatus","error","errorUpdatedAt","status","select","selectError","placeholderData","Date","now","isFetching","isPending","isError","isLoading","hasData","isSuccess","isInitialLoading","dataUpdatedAt","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isStale","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","throwOnError","some","typedKey","changed","has","promise","catch","time","timeout","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","batch","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","value","suspense","isStaleByTime","optimisticResult","getCurrentResult"],"sources":["/Users/andrew/node_modules/@tanstack/query-core/src/queryObserver.ts"],"sourcesContent":["import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { fetchState } from './query'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  listeners?: boolean\n}\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key as keyof QueryObserverResult)\n          onPropTracked?.(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Select data if needed\n    if (options.select && newState.data !== undefined) {\n      // Memoize select result\n      if (\n        prevResult &&\n        newState.data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(newState.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = newState.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n        if (options.select && placeholderData !== undefined) {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.#selectError = null\n          } catch (selectError) {\n            this.#selectError = selectError as TError\n          }\n        }\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = {}\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}