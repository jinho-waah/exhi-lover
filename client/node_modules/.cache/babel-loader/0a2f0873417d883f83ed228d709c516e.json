{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n\n  if (config == null) {\n    throw new Error([`MUI: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit'\n    };\n  }\n\n  return {\n    type: config.sectionType,\n    contentType: config.contentType\n  };\n};\n\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n\n    case 'ArrowDown':\n      return -1;\n\n    case 'PageUp':\n      return 5;\n\n    case 'PageDown':\n      return -5;\n\n    default:\n      return 0;\n  }\n};\n\nexport const getDaysInWeekStr = (utils, format) => {\n  const elements = [];\n  const now = utils.date();\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (utils, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return utils.getMonthArray(utils.date()).map(month => utils.formatByString(month, format));\n      }\n\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, format);\n      }\n\n    case 'meridiem':\n      {\n        const now = utils.date();\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport const cleanDigitSectionValue = (utils, value, sectionType, format, hasLeadingZeros, sectionBoundaries) => {\n  const hasLetter = () => {\n    const startOfYear = utils.startOfYear(utils.date());\n    const startOfYearStr = utils.formatByString(startOfYear, format);\n    return Number.isNaN(Number(startOfYearStr));\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (sectionType !== 'day' && hasLetter()) {\n      throw new Error([`MUI: The token \"${format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n\n  if (sectionType === 'day' && hasLetter()) {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, format);\n  } // queryValue without leading `0` (`01` => `1`)\n\n\n  const valueStr = value.toString();\n\n  if (hasLeadingZeros) {\n    const size = utils.formatByString(utils.date(), format).length;\n    let cleanValueStr = valueStr; // Remove the leading zeros\n\n    cleanValueStr = Number(cleanValueStr).toString(); // Add enough leading zeros to fill the section\n\n    while (cleanValueStr.length < size) {\n      cleanValueStr = `0${cleanValueStr}`;\n    }\n\n    return cleanValueStr;\n  }\n\n  return valueStr;\n};\nexport const adjustSectionValue = (utils, section, keyCode, sectionsValueBoundaries, activeDate) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n\n    const getCleanValue = value => cleanDigitSectionValue(utils, value, section.type, section.format, section.hasLeadingZeros, sectionBoundaries);\n\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(), section.format);\n      }\n\n      if (delta > 0 || isStart) {\n        return getCleanValue(sectionBoundaries.minimum);\n      }\n\n      return getCleanValue(sectionBoundaries.maximum);\n    }\n\n    const currentSectionValue = parseInt(section.value, 10);\n    const newSectionValueNumber = currentSectionValue + delta;\n\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum);\n    }\n\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum);\n    }\n\n    return getCleanValue(newSectionValueNumber);\n  };\n\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, section.type, section.format);\n\n    if (options.length === 0) {\n      return section.value;\n    }\n\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n\n      return options[options.length - 1];\n    }\n\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n\n  if (section.contentType === 'digit') {\n    return adjustDigitSection();\n  }\n\n  return adjustLetterSection();\n};\n\nconst getSectionVisibleValue = (section, willBeRenderedInInput) => {\n  const value = section.value || section.placeholder; // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  // Adding the ltr mark is not a problem because it's only for digit (which are always ltr)\n  // The \\u2068 and \\u2069 are cleaned, but not the \\u200e to notice that an update with same digit occurs\n\n  if (willBeRenderedInInput && section.contentType === 'digit' && !section.hasLeadingZeros && value.length === 1) {\n    return `\\u2068${value}\\u200e\\u2069`;\n  }\n\n  if (willBeRenderedInInput) {\n    return `\\u2068${value}\\u2069`;\n  }\n\n  return value;\n};\n\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = sections => {\n  let position = 0;\n  let positionInInput = 1;\n  const newSections = [];\n\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, true);\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length; // The ...InInput values consider the unicode characters but do include them in their indexes\n\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength; // Move position to the end of string associated to the current section\n\n    positionInInput += sectionLengthInInput;\n  }\n\n  return newSections;\n};\n\nconst getSectionPlaceholder = (utils, localeText, sectionConfig, currentTokenValue) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(), currentTokenValue).length\n        });\n      }\n\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder();\n      }\n\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder();\n      }\n\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder();\n      }\n\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder();\n      }\n\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder();\n      }\n\n    default:\n      {\n        return currentTokenValue;\n      }\n  }\n};\n\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\n\nconst isFourDigitYearFormat = (utils, format) => utils.formatByString(utils.date(), format).length === 4;\n\nexport const doesSectionHaveLeadingZeros = (utils, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(utils.date(), 1), format);\n          return formatted0001 === '0001';\n        }\n\n        const formatted2001 = utils.formatByString(utils.setYear(utils.date(), 2001), format);\n        return formatted2001 === '01';\n      }\n\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(utils.date()), format).length > 1;\n      }\n\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(utils.date()), format).length > 1;\n      }\n\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(utils.date()), format).length > 1;\n      }\n\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(utils.date(), 1), format).length > 1;\n      }\n\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\nconst getEscapedPartsFromFormat = (utils, format) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null; // eslint-disable-next-line no-cond-assign\n\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n\n  return escapedParts;\n};\n\nexport const splitFormatIntoSections = (utils, localeText, format, date) => {\n  let startSeparator = '';\n  const sections = [];\n\n  const commitToken = token => {\n    if (token === '') {\n      return null;\n    }\n\n    const expandedToken = utils.expandFormat(token);\n\n    if (expandedToken !== token) {\n      return expandedToken;\n    }\n\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    const sectionValue = date == null || !utils.isValid(date) ? '' : utils.formatByString(date, token);\n    const hasLeadingZeros = doesSectionHaveLeadingZeros(utils, sectionConfig.contentType, sectionConfig.type, token);\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),\n      hasLeadingZeros,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  };\n\n  const splitFormat = token => {\n    const escapedParts = getEscapedPartsFromFormat(utils, token);\n    let currentTokenValue = '';\n\n    for (let i = 0; i < token.length; i += 1) {\n      const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n      const char = token[i];\n      const isEscapedChar = escapedPartOfCurrentChar != null;\n\n      if (!isEscapedChar && char.match(/([A-Za-z]+)/)) {\n        currentTokenValue += char;\n      } else {\n        // If we are on the opening or closing character of an escaped part of the format,\n        // Then we ignore this character.\n        const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n\n        if (!isEscapeBoundary) {\n          const expandedToken = commitToken(currentTokenValue);\n\n          if (expandedToken != null) {\n            splitFormat(expandedToken);\n          }\n\n          currentTokenValue = '';\n\n          if (sections.length === 0) {\n            startSeparator += char;\n          } else {\n            sections[sections.length - 1].endSeparator += char;\n          }\n        }\n      }\n    }\n\n    const expandedToken = commitToken(currentTokenValue);\n\n    if (expandedToken != null) {\n      splitFormat(expandedToken);\n    }\n  };\n\n  splitFormat(format);\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n\n      if (cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n\n      if (cleanedSeparator === '/') {\n        cleanedSeparator = ' / ';\n      }\n\n      return cleanedSeparator;\n    };\n\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\n\nexport const getDateFromDateSections = (utils, sections) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, false));\n    }\n  }\n\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForInputFromSections = sections => {\n  const formattedArray = sections.map(section => `${section.startSeparator}${getSectionVisibleValue(section, true)}${section.endSeparator}`); // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n\n  return `\\u2066${formattedArray.join('')}\\u2069`;\n};\nexport const getSectionsBoundaries = utils => {\n  const today = utils.date();\n  const endOfYear = utils.endOfYear(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = utils.getMonthArray(today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: _ref => {\n      let {\n        format\n      } = _ref;\n      return {\n        minimum: 0,\n        maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99\n      };\n    },\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: _ref2 => {\n      let {\n        currentDate\n      } = _ref2;\n      return {\n        minimum: 1,\n        maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n        longestMonth: longestMonth\n      };\n    },\n    weekDay: _ref3 => {\n      let {\n        format,\n        contentType\n      } = _ref3;\n\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: _ref4 => {\n      let {\n        format\n      } = _ref4;\n      const lastHourInDay = utils.getHours(endOfYear);\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfYear)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfYear)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = [];\n\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n\n      if (invalidSection) {\n        console.warn(`MUI: The field component you are using is not compatible with the \"${invalidSection.type} date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\n\nconst transferDateSectionValue = (utils, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n\n        return dateToTransferTo;\n      }\n\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\n\nexport const mergeDateIntoReferenceDate = (utils, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => sections.reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, section, dateToTransferFrom, mergedDate);\n  }\n\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\nexport const clampDaySection = (utils, sections, sectionsValueBoundaries) => {\n  // We try to generate a valid date representing the start of the month of the invalid date typed by the user.\n  const sectionsForStartOfMonth = sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: null,\n      format: section.format,\n      contentType: section.contentType\n    });\n    return _extends({}, section, {\n      value: cleanDigitSectionValue(utils, dayBoundaries.minimum, section.type, section.format, section.hasLeadingZeros, dayBoundaries)\n    });\n  });\n  const startOfMonth = getDateFromDateSections(utils, sectionsForStartOfMonth); // Even the start of the month is invalid, we probably have other invalid sections, the clamping failed.\n\n  if (startOfMonth == null || !utils.isValid(startOfMonth)) {\n    return null;\n  } // The only invalid section was the day of the month, we replace its value with the maximum boundary for the correct month.\n\n\n  return sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: startOfMonth,\n      format: section.format,\n      contentType: section.contentType\n    });\n\n    if (Number(section.value) <= dayBoundaries.maximum) {\n      return section;\n    }\n\n    return _extends({}, section, {\n      value: dayBoundaries.maximum.toString()\n    });\n  });\n};\nexport const getSectionOrder = (sections, isRTL) => {\n  const neighbors = {};\n\n  if (!isRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex( // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' '));\n    });\n\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};","map":{"version":3,"names":["_extends","getDateSectionConfigFromFormatToken","utils","formatToken","config","formatTokenMap","Error","join","type","contentType","sectionType","getDeltaFromKeyCode","keyCode","getDaysInWeekStr","format","elements","now","date","startDate","startOfWeek","endDate","endOfWeek","current","isBefore","push","addDays","map","weekDay","formatByString","getLetterEditingOptions","getMonthArray","month","startOfDay","endOfDay","cleanDigitSectionValue","value","hasLeadingZeros","sectionBoundaries","hasLetter","startOfYear","startOfYearStr","Number","isNaN","process","env","NODE_ENV","setDate","longestMonth","valueStr","toString","size","length","cleanValueStr","adjustSectionValue","section","sectionsValueBoundaries","activeDate","delta","isStart","isEnd","shouldSetAbsolute","adjustDigitSection","currentDate","getCleanValue","minimum","maximum","currentSectionValue","parseInt","newSectionValueNumber","adjustLetterSection","options","currentOptionIndex","indexOf","newOptionIndex","getSectionVisibleValue","willBeRenderedInInput","placeholder","cleanString","dirtyString","replace","addPositionPropertiesToSections","sections","position","positionInInput","newSections","i","renderedValue","sectionStr","startSeparator","endSeparator","sectionLength","sectionLengthInInput","cleanedValue","startInInput","endInInput","start","end","getSectionPlaceholder","localeText","sectionConfig","currentTokenValue","fieldYearPlaceholder","digitAmount","fieldMonthPlaceholder","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","changeSectionValueFormat","currentFormat","newFormat","parse","isFourDigitYearFormat","doesSectionHaveLeadingZeros","formatted0001","setYear","formatted2001","startOfMonth","setHours","setMinutes","getEscapedPartsFromFormat","escapedParts","startChar","endChar","escapedCharacters","regExp","RegExp","match","exec","index","lastIndex","splitFormatIntoSections","commitToken","token","expandedToken","expandFormat","sectionValue","isValid","modified","splitFormat","escapedPartOfCurrentChar","find","escapeIndex","char","isEscapedChar","isEscapeBoundary","cleanSeparator","separator","cleanedSeparator","includes","getDateFromDateSections","shouldSkipWeekDays","some","sectionFormats","sectionValues","shouldSkip","formatWithoutSeparator","dateWithoutSeparatorStr","createDateStrForInputFromSections","formattedArray","getSectionsBoundaries","today","endOfYear","maxDaysInMonth","reduce","acc","daysInMonth","getDaysInMonth","year","getMonth","day","daysInWeek","Math","min","max","hours","lastHourInDay","getHours","hasMeridiem","minutes","getMinutes","seconds","getSeconds","meridiem","warnedOnceInvalidSection","validateSections","valueType","supportedSections","invalidSection","console","warn","transferDateSectionValue","dateToTransferFrom","dateToTransferTo","getYear","setMonth","formattedDaysInWeek","dayInWeekStrOfActiveDate","dayInWeekOfActiveDate","dayInWeekOfNewSectionValue","diff","getDate","isAM","mergedDateHours","addHours","setSeconds","mergeDateIntoReferenceDate","referenceDate","shouldLimitToEditedSections","mergedDate","isAndroid","navigator","userAgent","toLowerCase","clampDaySection","sectionsForStartOfMonth","dayBoundaries","getSectionOrder","isRTL","neighbors","forEach","_","leftIndex","rightIndex","startIndex","endIndex","rtl2ltr","ltr2rtl","groupedSectionsStart","groupedSectionsEnd","RTLIndex","findIndex","_section$endSeparator","rtlIndex"],"sources":["/Users/andrew/Desktop/exhi/exhi/client/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.utils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit'\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType\n  };\n};\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nexport const getDaysInWeekStr = (utils, format) => {\n  const elements = [];\n  const now = utils.date();\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (utils, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return utils.getMonthArray(utils.date()).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.date();\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport const cleanDigitSectionValue = (utils, value, sectionType, format, hasLeadingZeros, sectionBoundaries) => {\n  const hasLetter = () => {\n    const startOfYear = utils.startOfYear(utils.date());\n    const startOfYearStr = utils.formatByString(startOfYear, format);\n    return Number.isNaN(Number(startOfYearStr));\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    if (sectionType !== 'day' && hasLetter()) {\n      throw new Error([`MUI: The token \"${format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n  if (sectionType === 'day' && hasLetter()) {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  const valueStr = value.toString();\n  if (hasLeadingZeros) {\n    const size = utils.formatByString(utils.date(), format).length;\n    let cleanValueStr = valueStr;\n\n    // Remove the leading zeros\n    cleanValueStr = Number(cleanValueStr).toString();\n\n    // Add enough leading zeros to fill the section\n    while (cleanValueStr.length < size) {\n      cleanValueStr = `0${cleanValueStr}`;\n    }\n    return cleanValueStr;\n  }\n  return valueStr;\n};\nexport const adjustSectionValue = (utils, section, keyCode, sectionsValueBoundaries, activeDate) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    const getCleanValue = value => cleanDigitSectionValue(utils, value, section.type, section.format, section.hasLeadingZeros, sectionBoundaries);\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(), section.format);\n      }\n      if (delta > 0 || isStart) {\n        return getCleanValue(sectionBoundaries.minimum);\n      }\n      return getCleanValue(sectionBoundaries.maximum);\n    }\n    const currentSectionValue = parseInt(section.value, 10);\n    const newSectionValueNumber = currentSectionValue + delta;\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum);\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum);\n    }\n    return getCleanValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n  if (section.contentType === 'digit') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nconst getSectionVisibleValue = (section, willBeRenderedInInput) => {\n  const value = section.value || section.placeholder;\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  // Adding the ltr mark is not a problem because it's only for digit (which are always ltr)\n  // The \\u2068 and \\u2069 are cleaned, but not the \\u200e to notice that an update with same digit occurs\n  if (willBeRenderedInInput && section.contentType === 'digit' && !section.hasLeadingZeros && value.length === 1) {\n    return `\\u2068${value}\\u200e\\u2069`;\n  }\n  if (willBeRenderedInInput) {\n    return `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = sections => {\n  let position = 0;\n  let positionInInput = 1;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, true);\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nconst getSectionPlaceholder = (utils, localeText, sectionConfig, currentTokenValue) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(), currentTokenValue).length\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder();\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder();\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder();\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder();\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder();\n      }\n    default:\n      {\n        return currentTokenValue;\n      }\n  }\n};\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (utils, format) => utils.formatByString(utils.date(), format).length === 4;\nexport const doesSectionHaveLeadingZeros = (utils, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(utils.date(), 1), format);\n          return formatted0001 === '0001';\n        }\n        const formatted2001 = utils.formatByString(utils.setYear(utils.date(), 2001), format);\n        return formatted2001 === '01';\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(utils.date()), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(utils.date()), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(utils.date()), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(utils.date(), 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setMinutes(utils.date(), 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\nconst getEscapedPartsFromFormat = (utils, format) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nexport const splitFormatIntoSections = (utils, localeText, format, date) => {\n  let startSeparator = '';\n  const sections = [];\n  const commitToken = token => {\n    if (token === '') {\n      return null;\n    }\n    const expandedToken = utils.expandFormat(token);\n    if (expandedToken !== token) {\n      return expandedToken;\n    }\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    const sectionValue = date == null || !utils.isValid(date) ? '' : utils.formatByString(date, token);\n    const hasLeadingZeros = doesSectionHaveLeadingZeros(utils, sectionConfig.contentType, sectionConfig.type, token);\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),\n      hasLeadingZeros,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  };\n  const splitFormat = token => {\n    const escapedParts = getEscapedPartsFromFormat(utils, token);\n    let currentTokenValue = '';\n    for (let i = 0; i < token.length; i += 1) {\n      const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n      const char = token[i];\n      const isEscapedChar = escapedPartOfCurrentChar != null;\n      if (!isEscapedChar && char.match(/([A-Za-z]+)/)) {\n        currentTokenValue += char;\n      } else {\n        // If we are on the opening or closing character of an escaped part of the format,\n        // Then we ignore this character.\n        const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n        if (!isEscapeBoundary) {\n          const expandedToken = commitToken(currentTokenValue);\n          if (expandedToken != null) {\n            splitFormat(expandedToken);\n          }\n          currentTokenValue = '';\n          if (sections.length === 0) {\n            startSeparator += char;\n          } else {\n            sections[sections.length - 1].endSeparator += char;\n          }\n        }\n      }\n    }\n    const expandedToken = commitToken(currentTokenValue);\n    if (expandedToken != null) {\n      splitFormat(expandedToken);\n    }\n  };\n  splitFormat(format);\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (cleanedSeparator === '/') {\n        cleanedSeparator = ' / ';\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexport const getDateFromDateSections = (utils, sections) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, false));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForInputFromSections = sections => {\n  const formattedArray = sections.map(section => `${section.startSeparator}${getSectionVisibleValue(section, true)}${section.endSeparator}`);\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${formattedArray.join('')}\\u2069`;\n};\nexport const getSectionsBoundaries = utils => {\n  const today = utils.date();\n  const endOfYear = utils.endOfYear(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = utils.getMonthArray(today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n      longestMonth: longestMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = utils.getHours(endOfYear);\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfYear)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfYear)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = [];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI: The field component you are using is not compatible with the \"${invalidSection.type} date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (utils, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nexport const mergeDateIntoReferenceDate = (utils, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => sections.reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\nexport const clampDaySection = (utils, sections, sectionsValueBoundaries) => {\n  // We try to generate a valid date representing the start of the month of the invalid date typed by the user.\n  const sectionsForStartOfMonth = sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: null,\n      format: section.format,\n      contentType: section.contentType\n    });\n    return _extends({}, section, {\n      value: cleanDigitSectionValue(utils, dayBoundaries.minimum, section.type, section.format, section.hasLeadingZeros, dayBoundaries)\n    });\n  });\n  const startOfMonth = getDateFromDateSections(utils, sectionsForStartOfMonth);\n\n  // Even the start of the month is invalid, we probably have other invalid sections, the clamping failed.\n  if (startOfMonth == null || !utils.isValid(startOfMonth)) {\n    return null;\n  }\n\n  // The only invalid section was the day of the month, we replace its value with the maximum boundary for the correct month.\n  return sections.map(section => {\n    if (section.type !== 'day') {\n      return section;\n    }\n    const dayBoundaries = sectionsValueBoundaries.day({\n      currentDate: startOfMonth,\n      format: section.format,\n      contentType: section.contentType\n    });\n    if (Number(section.value) <= dayBoundaries.maximum) {\n      return section;\n    }\n    return _extends({}, section, {\n      value: dayBoundaries.maximum.toString()\n    });\n  });\n};\nexport const getSectionOrder = (sections, isRTL) => {\n  const neighbors = {};\n  if (!isRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' '));\n    });\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}