{"ast":null,"code":"import _regeneratorRuntime from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, ensureQueryFn } from \"./utils.js\";\n\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: function onFetch(context, query) {\n      var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$state$data, _context$state$data2;\n\n      var options = context.options;\n      var direction = (_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) === null || _context$fetchOptions2 === void 0 ? void 0 : (_context$fetchOptions3 = _context$fetchOptions2.fetchMore) === null || _context$fetchOptions3 === void 0 ? void 0 : _context$fetchOptions3.direction;\n      var oldPages = ((_context$state$data = context.state.data) === null || _context$state$data === void 0 ? void 0 : _context$state$data.pages) || [];\n      var oldPageParams = ((_context$state$data2 = context.state.data) === null || _context$state$data2 === void 0 ? void 0 : _context$state$data2.pageParams) || [];\n      var result = {\n        pages: [],\n        pageParams: []\n      };\n      var currentPage = 0;\n\n      var fetchFn = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var cancelled, addSignalProperty, queryFn, fetchPage, previous, pageParamFn, oldData, param, remainingPages, _oldPageParams$, _param;\n\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  cancelled = false;\n\n                  addSignalProperty = function addSignalProperty(object) {\n                    Object.defineProperty(object, \"signal\", {\n                      enumerable: true,\n                      get: function get() {\n                        if (context.signal.aborted) {\n                          cancelled = true;\n                        } else {\n                          context.signal.addEventListener(\"abort\", function () {\n                            cancelled = true;\n                          });\n                        }\n\n                        return context.signal;\n                      }\n                    });\n                  };\n\n                  queryFn = ensureQueryFn(context.options, context.fetchOptions);\n\n                  fetchPage = /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data, param, previous) {\n                      var queryFnContext, page, maxPages, addTo;\n                      return _regeneratorRuntime().wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              if (!cancelled) {\n                                _context.next = 2;\n                                break;\n                              }\n\n                              return _context.abrupt(\"return\", Promise.reject());\n\n                            case 2:\n                              if (!(param == null && data.pages.length)) {\n                                _context.next = 4;\n                                break;\n                              }\n\n                              return _context.abrupt(\"return\", Promise.resolve(data));\n\n                            case 4:\n                              queryFnContext = {\n                                queryKey: context.queryKey,\n                                pageParam: param,\n                                direction: previous ? \"backward\" : \"forward\",\n                                meta: context.options.meta\n                              };\n                              addSignalProperty(queryFnContext);\n                              _context.next = 8;\n                              return queryFn(queryFnContext);\n\n                            case 8:\n                              page = _context.sent;\n                              maxPages = context.options.maxPages;\n                              addTo = previous ? addToStart : addToEnd;\n                              return _context.abrupt(\"return\", {\n                                pages: addTo(data.pages, page, maxPages),\n                                pageParams: addTo(data.pageParams, param, maxPages)\n                              });\n\n                            case 12:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function fetchPage(_x, _x2, _x3) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }();\n\n                  if (!(direction && oldPages.length)) {\n                    _context2.next = 14;\n                    break;\n                  }\n\n                  previous = direction === \"backward\";\n                  pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n                  oldData = {\n                    pages: oldPages,\n                    pageParams: oldPageParams\n                  };\n                  param = pageParamFn(options, oldData);\n                  _context2.next = 11;\n                  return fetchPage(oldData, param, previous);\n\n                case 11:\n                  result = _context2.sent;\n                  _context2.next = 23;\n                  break;\n\n                case 14:\n                  remainingPages = pages !== null && pages !== void 0 ? pages : oldPages.length;\n\n                case 15:\n                  _param = currentPage === 0 ? (_oldPageParams$ = oldPageParams[0]) !== null && _oldPageParams$ !== void 0 ? _oldPageParams$ : options.initialPageParam : getNextPageParam(options, result);\n\n                  if (!(currentPage > 0 && _param == null)) {\n                    _context2.next = 18;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"break\", 23);\n\n                case 18:\n                  _context2.next = 20;\n                  return fetchPage(result, _param);\n\n                case 20:\n                  result = _context2.sent;\n                  currentPage++;\n\n                case 22:\n                  if (currentPage < remainingPages) {\n                    _context2.next = 15;\n                    break;\n                  }\n\n                case 23:\n                  return _context2.abrupt(\"return\", result);\n\n                case 24:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function fetchFn() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      if (context.options.persister) {\n        context.fetchFn = function () {\n          var _context$options$pers, _context$options;\n\n          return (_context$options$pers = (_context$options = context.options).persister) === null || _context$options$pers === void 0 ? void 0 : _context$options$pers.call(_context$options, fetchFn, {\n            queryKey: context.queryKey,\n            meta: context.options.meta,\n            signal: context.signal\n          }, query);\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\n\nfunction getNextPageParam(options, _ref3) {\n  var pages = _ref3.pages,\n      pageParams = _ref3.pageParams;\n  var lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams) : void 0;\n}\n\nfunction getPreviousPageParam(options, _ref4) {\n  var _options$getPreviousP;\n\n  var pages = _ref4.pages,\n      pageParams = _ref4.pageParams;\n  return pages.length > 0 ? (_options$getPreviousP = options.getPreviousPageParam) === null || _options$getPreviousP === void 0 ? void 0 : _options$getPreviousP.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;\n}\n\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\n\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\n\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"mappings":";;;AAAA,SAASA,QAAT,EAAmBC,UAAnB,EAA+BC,aAA/B,QAAoD,YAApD;;AAUO,SAASC,qBAAT,CACLC,KADK,EAEiE;EACtE,OAAO;IACLC,SAAS,iBAACC,OAAD,EAAUC,KAAV,EAAoB;MAAA;;MAC3B,IAAMC,UAAUF,QAAQE,OAAxB;MACA,IAAMC,qCAAYH,QAAQI,YAApB,oFAAY,sBAAsBC,IAAlC,qFAAY,uBAA4BC,SAAxC,2DAAY,uBAAuCH,SAAzD;MACA,IAAMI,WAAW,gCAAQC,KAAR,CAAcC,IAAd,4EAAoBX,KAApB,KAA6B,EAA9C;MACA,IAAMY,gBAAgB,iCAAQF,KAAR,CAAcC,IAAd,8EAAoBE,UAApB,KAAkC,EAAxD;MACA,IAAIC,SAAgC;QAAEd,OAAO,EAAT;QAAaa,YAAY;MAAzB,CAApC;MACA,IAAIE,cAAc,CAAlB;;MAEA,IAAMC;QAAA,sEAAU;UAAA;;UAAA;YAAA;cAAA;gBAAA;kBACVC,SADU,GACE,KADF;;kBAERC,iBAFQ,GAEY,SAApBA,iBAAoB,CAACC,MAAD,EAAqB;oBAC7CC,OAAOC,cAAP,CAAsBF,MAAtB,EAA8B,QAA9B,EAAwC;sBACtCG,YAAY,IAD0B;sBAEtCC,KAAK,eAAM;wBACT,IAAIrB,QAAQsB,MAAR,CAAeC,OAAnB,EAA4B;0BAC1BR,YAAY,IAAZ;wBACF,CAFA,MAEO;0BACLf,QAAQsB,MAAR,CAAeE,gBAAf,CAAgC,OAAhC,EAAyC,YAAM;4BAC7CT,YAAY,IAAZ;0BACD,CAFD;wBAGF;;wBACA,OAAOf,QAAQsB,MAAf;sBACF;oBAXsC,CAAxC;kBAaF,CAhBc;;kBAkBRG,OAlBQ,GAkBE7B,cAAcI,QAAQE,OAAtB,EAA+BF,QAAQI,YAAvC,CAlBF;;kBAqBRsB,SArBQ;oBAAA,uEAqBI,iBAChBjB,IADgB,EAEhBkB,KAFgB,EAGhBC,QAHgB;sBAAA;sBAAA;wBAAA;0BAAA;4BAAA;8BAAA,KAKZb,SALY;gCAAA;gCAAA;8BAAA;;8BAAA,iCAMPc,QAAQC,MAAR,EANO;;4BAAA;8BAAA,MASZH,SAAS,IAAT,IAAiBlB,KAAKX,KAAL,CAAWiC,MAThB;gCAAA;gCAAA;8BAAA;;8BAAA,iCAUPF,QAAQG,OAAR,CAAgBvB,IAAhB,CAVO;;4BAAA;8BAaVwB,cAbU,GAgBZ;gCACFC,UAAUlC,QAAQkC,QADhB;gCAEFC,WAAWR,KAFT;gCAGFxB,WAAWyB,WAAW,UAAX,GAAwB,SAHjC;gCAIFvB,MAAML,QAAQE,OAAR,CAAgBG;8BAJpB,CAhBY;8BAuBhBW,kBAAkBiB,cAAlB;8BAvBgB;8BAAA,OAyBGR,QACjBQ,cADiB,CAzBH;;4BAAA;8BAyBVG,IAzBU;8BA6BRC,QA7BQ,GA6BKrC,QAAQE,OA7Bb,CA6BRmC,QA7BQ;8BA8BVC,KA9BU,GA8BFV,WAAWjC,UAAX,GAAwBD,QA9BtB;8BAAA,iCAgCT;gCACLI,OAAOwC,MAAM7B,KAAKX,KAAX,EAAkBsC,IAAlB,EAAwBC,QAAxB,CADF;gCAEL1B,YAAY2B,MAAM7B,KAAKE,UAAX,EAAuBgB,KAAvB,EAA8BU,QAA9B;8BAFP,CAhCS;;4BAAA;4BAAA;8BAAA;0BAAA;wBAAA;sBAAA;oBAAA,CArBJ;;oBAAA,gBAqBRX,SArBQ;sBAAA;oBAAA;kBAAA;;kBAAA,MA4DVvB,aAAaI,SAASwB,MA5DZ;oBAAA;oBAAA;kBAAA;;kBA6DNH,QA7DM,GA6DKzB,cAAc,UA7DnB;kBA8DNoC,WA9DM,GA8DQX,WAAWY,oBAAX,GAAkCC,gBA9D1C;kBA+DNC,OA/DM,GA+DI;oBACd5C,OAAOS,QADO;oBAEdI,YAAYD;kBAFE,CA/DJ;kBAmENiB,KAnEM,GAmEEY,YAAYrC,OAAZ,EAAqBwC,OAArB,CAnEF;kBAAA;kBAAA,OAqEGhB,UAAUgB,OAAV,EAAmBf,KAAnB,EAA0BC,QAA1B,CArEH;;gBAAA;kBAqEZhB,MArEY;kBAAA;kBAAA;;gBAAA;kBAuEN+B,cAvEM,GAuEW7C,KAvEX,aAuEWA,KAvEX,cAuEWA,KAvEX,GAuEoBS,SAASwB,MAvE7B;;gBAAA;kBA2EJJ,MA3EI,GA4ERd,gBAAgB,CAAhB,sBACKH,cAAc,CAAd,CADL,6DACyBR,QAAQ0C,gBADjC,GAEIH,iBAAiBvC,OAAjB,EAA0BU,MAA1B,CA9EI;;kBAAA,MA+ENC,cAAc,CAAd,IAAmBc,UAAS,IA/EtB;oBAAA;oBAAA;kBAAA;;kBAAA;;gBAAA;kBAAA;kBAAA,OAkFKD,UAAUd,MAAV,EAAkBe,MAAlB,CAlFL;;gBAAA;kBAkFVf,MAlFU;kBAmFVC;;gBAnFU;kBAAA,IAoFHA,cAAc8B,cApFX;oBAAA;oBAAA;kBAAA;;gBAAA;kBAAA,kCAuFP/B,MAvFO;;gBAAA;gBAAA;kBAAA;cAAA;YAAA;UAAA;QAAA,CAAV;;QAAA;UAAA;QAAA;MAAA,GAAN;;MAyFA,IAAIZ,QAAQE,OAAR,CAAgB2C,SAApB,EAA+B;QAC7B7C,QAAQc,OAAR,GAAkB,YAAM;UAAA;;UACtB,gCAAO,4BAAQZ,OAAR,EAAgB2C,SAAvB,0DAAO,6CACL/B,OADK,EAEL;YACEoB,UAAUlC,QAAQkC,QADpB;YAEE7B,MAAML,QAAQE,OAAR,CAAgBG,IAFxB;YAGEiB,QAAQtB,QAAQsB;UAHlB,CAFK,EAOLrB,KAPK,CAAP;QASF,CAVA;MAWF,CAZA,MAYO;QACLD,QAAQc,OAAR,GAAkBA,OAAlB;MACF;IACF;EAjHK,CAAP;AAmHF;;AAEA,SAAS2B,gBAAT,CACEvC,OADF,SAGuB;EAAA,IADnBJ,KACmB,SADnBA,KACmB;EAAA,IADZa,UACY,SADZA,UACY;EACrB,IAAMmC,YAAYhD,MAAMiC,MAAN,GAAe,CAAjC;EACA,OAAOjC,MAAMiC,MAAN,GAAe,CAAf,GACH7B,QAAQuC,gBAAR,CACE3C,MAAMgD,SAAN,CADF,EAEEhD,KAFF,EAGEa,WAAWmC,SAAX,CAHF,EAIEnC,UAJF,CADG,GAOH,MAPJ;AAQF;;AAEA,SAAS6B,oBAAT,CACEtC,OADF,SAGuB;EAAA;;EAAA,IADnBJ,KACmB,SADnBA,KACmB;EAAA,IADZa,UACY,SADZA,UACY;EACrB,OAAOb,MAAMiC,MAAN,GAAe,CAAf,4BACH7B,QAAQsC,oBADL,0DACH,oCAA+B1C,MAAM,CAAN,CAA/B,EAAyCA,KAAzC,EAAgDa,WAAW,CAAX,CAAhD,EAA+DA,UAA/D,CADG,GAEH,MAFJ;AAGF;;AAKO,SAASoC,WAAT,CACL7C,OADK,EAELO,IAFK,EAGI;EACT,IAAI,CAACA,IAAL,EAAW,OAAO,KAAP;EACX,OAAOgC,iBAAiBvC,OAAjB,EAA0BO,IAA1B,KAAmC,IAA1C;AACF;;AAKO,SAASuC,eAAT,CACL9C,OADK,EAELO,IAFK,EAGI;EACT,IAAI,CAACA,IAAD,IAAS,CAACP,QAAQsC,oBAAtB,EAA4C,OAAO,KAAP;EAC5C,OAAOA,qBAAqBtC,OAArB,EAA8BO,IAA9B,KAAuC,IAA9C;AACF","names":["addToEnd","addToStart","ensureQueryFn","infiniteQueryBehavior","pages","onFetch","context","query","options","direction","fetchOptions","meta","fetchMore","oldPages","state","data","oldPageParams","pageParams","result","currentPage","fetchFn","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","queryFn","fetchPage","param","previous","Promise","reject","length","resolve","queryFnContext","queryKey","pageParam","page","maxPages","addTo","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","remainingPages","initialPageParam","persister","lastIndex","hasNextPage","hasPreviousPage"],"sources":["/Users/andrew/node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts"],"sourcesContent":["import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: OmitKeyof<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"]},"metadata":{},"sourceType":"module"}