{"ast":null,"code":"// src/queriesObserver.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { QueryObserver } from \"./queryObserver.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { replaceEqualDeep } from \"./utils.js\";\n\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\n\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\n\nvar QueriesObserver = class extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #observers;\n  #combinedResult;\n  #lastCombine;\n  #lastResult;\n\n  constructor(client, queries, _options) {\n    super();\n    this.#client = client;\n    this.#queries = [];\n    this.#observers = [];\n    this.#result = [];\n    this.setQueries(queries);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    this.#observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, _options, notifyOptions) {\n    this.#queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.#observers = newObservers;\n      this.#result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n      this.#notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.#result;\n  }\n\n  getQueries() {\n    return this.#observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.#observers;\n  }\n\n  getOptimisticResult(queries, combine) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n    return [result, r => {\n      return this.#combineResult(r ?? result, combine);\n    }, () => {\n      return matches.map((match, index) => {\n        const observerResult = result[index];\n        return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult, accessedProp => {\n          matches.forEach(m => {\n            m.observer.trackProp(accessedProp);\n          });\n        }) : observerResult;\n      });\n    }];\n  }\n\n  #combineResult(input, combine) {\n    if (combine) {\n      if (!this.#combinedResult || this.#result !== this.#lastResult || combine !== this.#lastCombine) {\n        this.#lastCombine = combine;\n        this.#lastResult = this.#result;\n        this.#combinedResult = replaceEqualDeep(this.#combinedResult, combine(input));\n      }\n\n      return this.#combinedResult;\n    }\n\n    return input;\n  }\n\n  #findMatchingObservers(queries) {\n    const prevObservers = this.#observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.#client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n\n    const getObserver = options => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const currentObserver = this.#observers.find(o => o.options.queryHash === defaultedOptions.queryHash);\n      return currentObserver ?? new QueryObserver(this.#client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map(options => {\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result);\n      this.#notify();\n    }\n  }\n\n  #notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.#result);\n      });\n    });\n  }\n\n};\nexport { QueriesObserver };","map":{"version":3,"mappings":"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","names":["notifyManager","QueryObserver","Subscribable","replaceEqualDeep","difference","array1","array2","filter","x","includes","replaceAt","array","index","value","copy","slice","QueriesObserver","constructor","client","queries","_options","setQueries","onSubscribe","listeners","size","forEach","observer","subscribe","result","onUnsubscribe","destroy","Set","notifyOptions","batch","prevObservers","newObserverMatches","match","setOptions","defaultedQueryOptions","newObservers","map","newResult","getCurrentResult","hasIndexChange","some","length","hasListeners","getQueries","getCurrentQuery","getObservers","getOptimisticResult","combine","matches","r","observerResult","notifyOnChangeProps","trackResult","accessedProp","m","trackProp","input","prevObserversMap","Map","options","queryHash","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","get","matchedQueryHashes","unmatchedQueries","has","getObserver","currentObserver","find","o","newOrReusedObservers","sortMatchesByOrderOfQueries","a","b","indexOf","concat","sort","listener"],"sources":["/Users/andrew/node_modules/@tanstack/query-core/src/queriesObserver.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #observers: Array<QueryObserver>\n  #combinedResult?: TCombinedResult\n  #lastCombine?: CombineFn<TCombinedResult>\n  #lastResult?: Array<QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions<any, any, any, any, any>>,\n    _options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#queries = []\n    this.#observers = []\n    this.#result = []\n\n    this.setQueries(queries)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    _options?: QueriesObserverOptions<TCombinedResult>,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.#queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): Array<QueryObserverResult> {\n    return this.#result\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine)\n      },\n      () => {\n        return matches.map((match, index) => {\n          const observerResult = result[index]!\n          return !match.defaultedQueryOptions.notifyOnChangeProps\n            ? match.observer.trackResult(observerResult, (accessedProp) => {\n                // track property on all observers to ensure proper (synchronized) tracking (#7000)\n                matches.forEach((m) => {\n                  m.observer.trackProp(accessedProp)\n                })\n              })\n            : observerResult\n        })\n      },\n    ]\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): TCombinedResult {\n    if (combine) {\n      if (\n        !this.#combinedResult ||\n        this.#result !== this.#lastResult ||\n        combine !== this.#lastCombine\n      ) {\n        this.#lastCombine = combine\n        this.#lastResult = this.#result\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input),\n        )\n      }\n\n      return this.#combinedResult\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObservers = this.#observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.#client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: Array<QueryObserverMatch> =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const currentObserver = this.#observers.find(\n        (o) => o.options.queryHash === defaultedOptions.queryHash,\n      )\n      return (\n        currentObserver ?? new QueryObserver(this.#client, defaultedOptions)\n      )\n    }\n\n    const newOrReusedObservers: Array<QueryObserverMatch> =\n      unmatchedQueries.map((options) => {\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      })\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result)\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(this.#result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n"]},"metadata":{},"sourceType":"module"}