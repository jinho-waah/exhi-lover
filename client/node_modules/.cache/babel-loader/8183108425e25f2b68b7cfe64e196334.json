{"ast":null,"code":"import _objectSpread from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classPrivateMethodInitSpec from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/Users/andrew/Desktop/exhi/exhi/exhi-lover/client/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\n\nvar _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _dispatch;\n\n// src/query.ts\nimport { ensureQueryFn, noop, replaceData, resolveEnabled, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = (_initialState = /*#__PURE__*/new WeakMap(), _revertState = /*#__PURE__*/new WeakMap(), _cache = /*#__PURE__*/new WeakMap(), _retryer = /*#__PURE__*/new WeakMap(), _defaultOptions = /*#__PURE__*/new WeakMap(), _abortSignalConsumed = /*#__PURE__*/new WeakMap(), _dispatch = /*#__PURE__*/new WeakSet(), /*#__PURE__*/function (_Removable) {\n  _inherits(Query, _Removable);\n\n  var _super = _createSuper(Query);\n\n  function Query(config) {\n    var _config$state;\n\n    var _this;\n\n    _classCallCheck(this, Query);\n\n    _this = _super.call(this);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _dispatch);\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _initialState, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _revertState, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _cache, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _retryer, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _defaultOptions, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _abortSignalConsumed, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _abortSignalConsumed, false);\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _defaultOptions, config.defaultOptions);\n\n    _this.setOptions(config.options);\n\n    _this.observers = [];\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _cache, config.cache);\n\n    _this.queryKey = config.queryKey;\n    _this.queryHash = config.queryHash;\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _initialState, getDefaultState(_this.options));\n\n    _this.state = (_config$state = config.state) !== null && _config$state !== void 0 ? _config$state : _classPrivateFieldGet(_assertThisInitialized(_this), _initialState);\n\n    _this.scheduleGc();\n\n    return _this;\n  }\n\n  _createClass(Query, [{\n    key: \"meta\",\n    get: function get() {\n      return this.options.meta;\n    }\n  }, {\n    key: \"promise\",\n    get: function get() {\n      var _classPrivateFieldGet2;\n\n      return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _retryer)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.promise;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = _objectSpread(_objectSpread({}, _classPrivateFieldGet(this, _defaultOptions)), options);\n      this.updateGcTime(this.options.gcTime);\n    }\n  }, {\n    key: \"optionalRemove\",\n    value: function optionalRemove() {\n      if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n        _classPrivateFieldGet(this, _cache).remove(this);\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(newData, options) {\n      var data = replaceData(this.state.data, newData, this.options);\n\n      _classPrivateMethodGet(this, _dispatch, _dispatch2).call(this, {\n        data: data,\n        type: \"success\",\n        dataUpdatedAt: options === null || options === void 0 ? void 0 : options.updatedAt,\n        manual: options === null || options === void 0 ? void 0 : options.manual\n      });\n\n      return data;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(state, setStateOptions) {\n      _classPrivateMethodGet(this, _dispatch, _dispatch2).call(this, {\n        type: \"setState\",\n        state: state,\n        setStateOptions: setStateOptions\n      });\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(options) {\n      var _classPrivateFieldGet3, _classPrivateFieldGet4;\n\n      var promise = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _retryer)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.promise;\n      (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _retryer)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.cancel(options);\n      return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Query.prototype), \"destroy\", this).call(this);\n\n      this.cancel({\n        silent: true\n      });\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.destroy();\n      this.setState(_classPrivateFieldGet(this, _initialState));\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      var _this2 = this;\n\n      return this.observers.some(function (observer) {\n        return resolveEnabled(observer.options.enabled, _this2) !== false;\n      });\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled() {\n      return this.getObserversCount() > 0 && !this.isActive();\n    }\n  }, {\n    key: \"isStale\",\n    value: function isStale() {\n      if (this.state.isInvalidated) {\n        return true;\n      }\n\n      if (this.getObserversCount() > 0) {\n        return this.observers.some(function (observer) {\n          return observer.getCurrentResult().isStale;\n        });\n      }\n\n      return this.state.data === void 0;\n    }\n  }, {\n    key: \"isStaleByTime\",\n    value: function isStaleByTime() {\n      var staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n    }\n  }, {\n    key: \"onFocus\",\n    value: function onFocus() {\n      var _classPrivateFieldGet5;\n\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnWindowFocus();\n      });\n      observer === null || observer === void 0 ? void 0 : observer.refetch({\n        cancelRefetch: false\n      });\n      (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _retryer)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.continue();\n    }\n  }, {\n    key: \"onOnline\",\n    value: function onOnline() {\n      var _classPrivateFieldGet6;\n\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnReconnect();\n      });\n      observer === null || observer === void 0 ? void 0 : observer.refetch({\n        cancelRefetch: false\n      });\n      (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _retryer)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.continue();\n    }\n  }, {\n    key: \"addObserver\",\n    value: function addObserver(observer) {\n      if (!this.observers.includes(observer)) {\n        this.observers.push(observer);\n        this.clearGcTimeout();\n\n        _classPrivateFieldGet(this, _cache).notify({\n          type: \"observerAdded\",\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"removeObserver\",\n    value: function removeObserver(observer) {\n      if (this.observers.includes(observer)) {\n        this.observers = this.observers.filter(function (x) {\n          return x !== observer;\n        });\n\n        if (!this.observers.length) {\n          if (_classPrivateFieldGet(this, _retryer)) {\n            if (_classPrivateFieldGet(this, _abortSignalConsumed)) {\n              _classPrivateFieldGet(this, _retryer).cancel({\n                revert: true\n              });\n            } else {\n              _classPrivateFieldGet(this, _retryer).cancelRetry();\n            }\n          }\n\n          this.scheduleGc();\n        }\n\n        _classPrivateFieldGet(this, _cache).notify({\n          type: \"observerRemoved\",\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"getObserversCount\",\n    value: function getObserversCount() {\n      return this.observers.length;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      if (!this.state.isInvalidated) {\n        _classPrivateMethodGet(this, _dispatch, _dispatch2).call(this, {\n          type: \"invalidate\"\n        });\n      }\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(options, fetchOptions) {\n      var _this3 = this,\n          _this$options$behavio,\n          _context$fetchOptions;\n\n      if (this.state.fetchStatus !== \"idle\") {\n        if (this.state.data !== void 0 && fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.cancelRefetch) {\n          this.cancel({\n            silent: true\n          });\n        } else if (_classPrivateFieldGet(this, _retryer)) {\n          _classPrivateFieldGet(this, _retryer).continueRetry();\n\n          return _classPrivateFieldGet(this, _retryer).promise;\n        }\n      }\n\n      if (options) {\n        this.setOptions(options);\n      }\n\n      if (!this.options.queryFn) {\n        var observer = this.observers.find(function (x) {\n          return x.options.queryFn;\n        });\n\n        if (observer) {\n          this.setOptions(observer.options);\n        }\n      }\n\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!Array.isArray(this.options.queryKey)) {\n          console.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n        }\n      }\n\n      var abortController = new AbortController();\n\n      var addSignalProperty = function addSignalProperty(object) {\n        Object.defineProperty(object, \"signal\", {\n          enumerable: true,\n          get: function get() {\n            _classPrivateFieldSet(_this3, _abortSignalConsumed, true);\n\n            return abortController.signal;\n          }\n        });\n      };\n\n      var fetchFn = function fetchFn() {\n        var queryFn = ensureQueryFn(_this3.options, fetchOptions);\n        var queryFnContext = {\n          queryKey: _this3.queryKey,\n          meta: _this3.meta\n        };\n        addSignalProperty(queryFnContext);\n\n        _classPrivateFieldSet(_this3, _abortSignalConsumed, false);\n\n        if (_this3.options.persister) {\n          return _this3.options.persister(queryFn, queryFnContext, _this3);\n        }\n\n        return queryFn(queryFnContext);\n      };\n\n      var context = {\n        fetchOptions: fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        state: this.state,\n        fetchFn: fetchFn\n      };\n      addSignalProperty(context);\n      (_this$options$behavio = this.options.behavior) === null || _this$options$behavio === void 0 ? void 0 : _this$options$behavio.onFetch(context, this);\n\n      _classPrivateFieldSet(this, _revertState, this.state);\n\n      if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 ? void 0 : _context$fetchOptions.meta)) {\n        var _context$fetchOptions2;\n\n        _classPrivateMethodGet(this, _dispatch, _dispatch2).call(this, {\n          type: \"fetch\",\n          meta: (_context$fetchOptions2 = context.fetchOptions) === null || _context$fetchOptions2 === void 0 ? void 0 : _context$fetchOptions2.meta\n        });\n      }\n\n      var onError = function onError(error) {\n        if (!(isCancelledError(error) && error.silent)) {\n          _classPrivateMethodGet(_this3, _dispatch, _dispatch2).call(_this3, {\n            type: \"error\",\n            error: error\n          });\n        }\n\n        if (!isCancelledError(error)) {\n          var _classPrivateFieldGet7, _classPrivateFieldGet8, _classPrivateFieldGet9, _classPrivateFieldGet10;\n\n          (_classPrivateFieldGet7 = (_classPrivateFieldGet8 = _classPrivateFieldGet(_this3, _cache).config).onError) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.call(_classPrivateFieldGet8, error, _this3);\n          (_classPrivateFieldGet9 = (_classPrivateFieldGet10 = _classPrivateFieldGet(_this3, _cache).config).onSettled) === null || _classPrivateFieldGet9 === void 0 ? void 0 : _classPrivateFieldGet9.call(_classPrivateFieldGet10, _this3.state.data, error, _this3);\n        }\n\n        if (!_this3.isFetchingOptimistic) {\n          _this3.scheduleGc();\n        }\n\n        _this3.isFetchingOptimistic = false;\n      };\n\n      _classPrivateFieldSet(this, _retryer, createRetryer({\n        initialPromise: fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.initialPromise,\n        fn: context.fetchFn,\n        abort: abortController.abort.bind(abortController),\n        onSuccess: function onSuccess(data) {\n          var _classPrivateFieldGet11, _classPrivateFieldGet12, _classPrivateFieldGet13, _classPrivateFieldGet14;\n\n          if (data === void 0) {\n            if (process.env.NODE_ENV !== \"production\") {\n              console.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \".concat(_this3.queryHash));\n            }\n\n            onError(new Error(\"\".concat(_this3.queryHash, \" data is undefined\")));\n            return;\n          }\n\n          try {\n            _this3.setData(data);\n          } catch (error) {\n            onError(error);\n            return;\n          }\n\n          (_classPrivateFieldGet11 = (_classPrivateFieldGet12 = _classPrivateFieldGet(_this3, _cache).config).onSuccess) === null || _classPrivateFieldGet11 === void 0 ? void 0 : _classPrivateFieldGet11.call(_classPrivateFieldGet12, data, _this3);\n          (_classPrivateFieldGet13 = (_classPrivateFieldGet14 = _classPrivateFieldGet(_this3, _cache).config).onSettled) === null || _classPrivateFieldGet13 === void 0 ? void 0 : _classPrivateFieldGet13.call(_classPrivateFieldGet14, data, _this3.state.error, _this3);\n\n          if (!_this3.isFetchingOptimistic) {\n            _this3.scheduleGc();\n          }\n\n          _this3.isFetchingOptimistic = false;\n        },\n        onError: onError,\n        onFail: function onFail(failureCount, error) {\n          _classPrivateMethodGet(_this3, _dispatch, _dispatch2).call(_this3, {\n            type: \"failed\",\n            failureCount: failureCount,\n            error: error\n          });\n        },\n        onPause: function onPause() {\n          _classPrivateMethodGet(_this3, _dispatch, _dispatch2).call(_this3, {\n            type: \"pause\"\n          });\n        },\n        onContinue: function onContinue() {\n          _classPrivateMethodGet(_this3, _dispatch, _dispatch2).call(_this3, {\n            type: \"continue\"\n          });\n        },\n        retry: context.options.retry,\n        retryDelay: context.options.retryDelay,\n        networkMode: context.options.networkMode,\n        canRun: function canRun() {\n          return true;\n        }\n      }));\n\n      return _classPrivateFieldGet(this, _retryer).start();\n    }\n  }]);\n\n  return Query;\n}(Removable));\n\nfunction _dispatch2(action) {\n  var _this4 = this;\n\n  var reducer = function reducer(state) {\n    var _action$meta, _action$dataUpdatedAt;\n\n    switch (action.type) {\n      case \"failed\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchFailureCount: action.failureCount,\n          fetchFailureReason: action.error\n        });\n\n      case \"pause\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchStatus: \"paused\"\n        });\n\n      case \"continue\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchStatus: \"fetching\"\n        });\n\n      case \"fetch\":\n        return _objectSpread(_objectSpread(_objectSpread({}, state), fetchState(state.data, _this4.options)), {}, {\n          fetchMeta: (_action$meta = action.meta) !== null && _action$meta !== void 0 ? _action$meta : null\n        });\n\n      case \"success\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) !== null && _action$dataUpdatedAt !== void 0 ? _action$dataUpdatedAt : Date.now(),\n          error: null,\n          isInvalidated: false,\n          status: \"success\"\n        }, !action.manual && {\n          fetchStatus: \"idle\",\n          fetchFailureCount: 0,\n          fetchFailureReason: null\n        });\n\n      case \"error\":\n        var error = action.error;\n\n        if (isCancelledError(error) && error.revert && _classPrivateFieldGet(_this4, _revertState)) {\n          return _objectSpread(_objectSpread({}, _classPrivateFieldGet(_this4, _revertState)), {}, {\n            fetchStatus: \"idle\"\n          });\n        }\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          error: error,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          fetchFailureReason: error,\n          fetchStatus: \"idle\",\n          status: \"error\"\n        });\n\n      case \"invalidate\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isInvalidated: true\n        });\n\n      case \"setState\":\n        return _objectSpread(_objectSpread({}, state), action.state);\n    }\n  };\n\n  this.state = reducer(this.state);\n  notifyManager.batch(function () {\n    _this4.observers.forEach(function (observer) {\n      observer.onQueryUpdate();\n    });\n\n    _classPrivateFieldGet(_this4, _cache).notify({\n      query: _this4,\n      type: \"updated\",\n      action: action\n    });\n  });\n}\n\nfunction fetchState(data, options) {\n  return _objectSpread({\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\"\n  }, data === void 0 && {\n    error: null,\n    status: \"pending\"\n  });\n}\n\nfunction getDefaultState(options) {\n  var data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  var hasData = data !== void 0;\n  var initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data: data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt !== null && initialDataUpdatedAt !== void 0 ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\nexport { Query, fetchState };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;AAAA,SACEA,aADF,EAEEC,IAFF,EAGEC,WAHF,EAIEC,cAJF,EAKEC,cALF,QAMO,YANP;AAOA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,QAAT,EAAmBC,aAAnB,EAAkCC,gBAAlC,QAA0D,cAA1D;AACA,SAASC,SAAT,QAA0B,gBAA1B;AAiJO,IAAMC;EAAA;;EAAA;;EAoBX,eAAYC,MAAZ,EAAyE;IAAA;;IAAA;;IAAA;;IACvE;;IADuE;;IAAA;MAAA;MAAA;IAAA;;IAAA;MAAA;MAAA;IAAA;;IAAA;MAAA;MAAA;IAAA;;IAAA;MAAA;MAAA;IAAA;;IAAA;MAAA;MAAA;IAAA;;IAAA;MAAA;MAAA;IAAA;;IAGvE,2EAA4B,KAA5B;;IACA,sEAAuBA,OAAOC,cAA9B;;IACA,MAAKC,UAAL,CAAgBF,OAAOG,OAAvB;;IACA,MAAKC,SAAL,GAAiB,EAAjB;;IACA,6DAAcJ,OAAOK,KAArB;;IACA,MAAKC,QAAL,GAAgBN,OAAOM,QAAvB;IACA,MAAKC,SAAL,GAAiBP,OAAOO,SAAxB;;IACA,oEAAqBC,gBAAgB,MAAKL,OAArB,CAArB;;IACA,MAAKM,KAAL,oBAAaT,OAAOS,KAApB;;IACA,MAAKC,UAAL;;IAZuE;EAazE;;EAjCW;IAAA;IAAA,KAkCX,eAAkC;MAChC,OAAO,KAAKP,OAAL,CAAaQ,IAApB;IACF;EApCW;IAAA;IAAA,KAsCX,eAA0C;MAAA;;MACxC,uDAAO,IAAP,sEAAO,uBAAeC,OAAtB;IACF;EAxCW;IAAA;IAAA,OA0CX,oBACET,OADF,EAEQ;MACN,KAAKA,OAAL,yDAAoB,IAApB,qBAA6CA,OAA7C;MAEA,KAAKU,YAAL,CAAkB,KAAKV,OAAL,CAAaW,MAA/B;IACF;EAhDW;IAAA;IAAA,OAkDD,0BAAiB;MACzB,IAAI,CAAC,KAAKV,SAAL,CAAeW,MAAhB,IAA0B,KAAKN,KAAL,CAAWO,WAAX,KAA2B,MAAzD,EAAiE;QAC/D,oCAAYC,MAAZ,CAAmB,IAAnB;MACF;IACF;EAtDW;IAAA;IAAA,OAwDX,iBACEC,OADF,EAEEf,OAFF,EAGS;MACP,IAAMgB,OAAO5B,YAAY,KAAKkB,KAAL,CAAWU,IAAvB,EAA6BD,OAA7B,EAAsC,KAAKf,OAA3C,CAAb;;MAGA,+DAAe;QACbgB,UADa;QAEbC,MAAM,SAFO;QAGbC,eAAelB,OAAf,aAAeA,OAAf,uBAAeA,QAASmB,SAHX;QAIbC,QAAQpB,OAAR,aAAQA,OAAR,uBAAQA,QAASoB;MAJJ,CAAf;;MAOA,OAAOJ,IAAP;IACF;EAvEW;IAAA;IAAA,OAyEX,kBACEV,KADF,EAEEe,eAFF,EAGQ;MACN,+DAAe;QAAEJ,MAAM,UAAR;QAAoBX,YAApB;QAA2Be;MAA3B,CAAf;IACF;EA9EW;IAAA;IAAA,OAgFX,gBAAOrB,OAAP,EAA+C;MAAA;;MAC7C,IAAMS,0DAAU,IAAV,sEAAU,uBAAeA,OAA/B;MACA,iJAAea,MAAf,CAAsBtB,OAAtB;MACA,OAAOS,UAAUA,QAAQc,IAAR,CAAapC,IAAb,EAAmBqC,KAAnB,CAAyBrC,IAAzB,CAAV,GAA2CsC,QAAQC,OAAR,EAAlD;IACF;EApFW;IAAA;IAAA,OAsFX,mBAAgB;MACd;;MAEA,KAAKJ,MAAL,CAAY;QAAEK,QAAQ;MAAV,CAAZ;IACF;EA1FW;IAAA;IAAA,OA4FX,iBAAc;MACZ,KAAKC,OAAL;MACA,KAAKC,QAAL,uBAAc,IAAd;IACF;EA/FW;IAAA;IAAA,OAiGX,oBAAoB;MAAA;;MAClB,OAAO,KAAK5B,SAAL,CAAe6B,IAAf,CACL,UAACC,QAAD;QAAA,OAAc1C,eAAe0C,SAAS/B,OAAT,CAAiBgC,OAAhC,EAAyC,MAAzC,MAAmD,KAAjE;MAAA,CADK,CAAP;IAGF;EArGW;IAAA;IAAA,OAuGX,sBAAsB;MACpB,OAAO,KAAKC,iBAAL,KAA2B,CAA3B,IAAgC,CAAC,KAAKC,QAAL,EAAxC;IACF;EAzGW;IAAA;IAAA,OA2GX,mBAAmB;MACjB,IAAI,KAAK5B,KAAL,CAAW6B,aAAf,EAA8B;QAC5B,OAAO,IAAP;MACF;;MAEA,IAAI,KAAKF,iBAAL,KAA2B,CAA/B,EAAkC;QAChC,OAAO,KAAKhC,SAAL,CAAe6B,IAAf,CACL,UAACC,QAAD;UAAA,OAAcA,SAASK,gBAAT,GAA4BC,OAA1C;QAAA,CADK,CAAP;MAGF;;MAEA,OAAO,KAAK/B,KAAL,CAAWU,IAAX,KAAoB,MAA3B;IACF;EAvHW;IAAA;IAAA,OAyHX,yBAAsC;MAAA,IAAxBsB,SAAwB,uEAAZ,CAAY;MACpC,OACE,KAAKhC,KAAL,CAAW6B,aAAX,IACA,KAAK7B,KAAL,CAAWU,IAAX,KAAoB,MADpB,IAEA,CAAC1B,eAAe,KAAKgB,KAAL,CAAWY,aAA1B,EAAyCoB,SAAzC,CAHH;IAKF;EA/HW;IAAA;IAAA,OAiIX,mBAAgB;MAAA;;MACd,IAAMP,WAAW,KAAK9B,SAAL,CAAesC,IAAf,CAAoB,UAACC,CAAD;QAAA,OAAOA,EAAEC,wBAAF,EAAP;MAAA,CAApB,CAAjB;MAEAV,6DAAUW,OAAV,CAAkB;QAAEC,eAAe;MAAjB,CAAlB;MAGA,iJAAeC,QAAf;IACF;EAxIW;IAAA;IAAA,OA0IX,oBAAiB;MAAA;;MACf,IAAMb,WAAW,KAAK9B,SAAL,CAAesC,IAAf,CAAoB,UAACC,CAAD;QAAA,OAAOA,EAAEK,sBAAF,EAAP;MAAA,CAApB,CAAjB;MAEAd,6DAAUW,OAAV,CAAkB;QAAEC,eAAe;MAAjB,CAAlB;MAGA,iJAAeC,QAAf;IACF;EAjJW;IAAA;IAAA,OAmJX,qBAAYb,QAAZ,EAAoE;MAClE,IAAI,CAAC,KAAK9B,SAAL,CAAe6C,QAAf,CAAwBf,QAAxB,CAAL,EAAwC;QACtC,KAAK9B,SAAL,CAAe8C,IAAf,CAAoBhB,QAApB;QAGA,KAAKiB,cAAL;;QAEA,oCAAYC,MAAZ,CAAmB;UAAEhC,MAAM,eAAR;UAAyBiC,OAAO,IAAhC;UAAsCnB;QAAtC,CAAnB;MACF;IACF;EA5JW;IAAA;IAAA,OA8JX,wBAAeA,QAAf,EAAuE;MACrE,IAAI,KAAK9B,SAAL,CAAe6C,QAAf,CAAwBf,QAAxB,CAAJ,EAAuC;QACrC,KAAK9B,SAAL,GAAiB,KAAKA,SAAL,CAAekD,MAAf,CAAsB,UAACX,CAAD;UAAA,OAAOA,MAAMT,QAAb;QAAA,CAAtB,CAAjB;;QAEA,IAAI,CAAC,KAAK9B,SAAL,CAAeW,MAApB,EAA4B;UAG1B,0BAAI,IAAJ,aAAmB;YACjB,0BAAI,IAAJ,yBAA+B;cAC7B,sCAAcU,MAAd,CAAqB;gBAAE8B,QAAQ;cAAV,CAArB;YACF,CAFA,MAEO;cACL,sCAAcC,WAAd;YACF;UACF;;UAEA,KAAK9C,UAAL;QACF;;QAEA,oCAAY0C,MAAZ,CAAmB;UAAEhC,MAAM,iBAAR;UAA2BiC,OAAO,IAAlC;UAAwCnB;QAAxC,CAAnB;MACF;IACF;EAlLW;IAAA;IAAA,OAoLX,6BAA4B;MAC1B,OAAO,KAAK9B,SAAL,CAAeW,MAAtB;IACF;EAtLW;IAAA;IAAA,OAwLX,sBAAmB;MACjB,IAAI,CAAC,KAAKN,KAAL,CAAW6B,aAAhB,EAA+B;QAC7B,+DAAe;UAAElB,MAAM;QAAR,CAAf;MACF;IACF;EA5LW;IAAA;IAAA,OA8LX,eACEjB,OADF,EAEEsD,YAFF,EAGkB;MAAA;MAAA;MAAA;;MAChB,IAAI,KAAKhD,KAAL,CAAWO,WAAX,KAA2B,MAA/B,EAAuC;QACrC,IAAI,KAAKP,KAAL,CAAWU,IAAX,KAAoB,MAApB,IAAiCsC,YAAjC,aAAiCA,YAAjC,eAAiCA,aAAcX,aAAnD,EAAkE;UAEhE,KAAKrB,MAAL,CAAY;YAAEK,QAAQ;UAAV,CAAZ;QACF,CAHA,MAGA,0BAAW,IAAX,aAA0B;UAExB,sCAAc4B,aAAd;;UAEA,OAAO,sCAAc9C,OAArB;QACF;MACF;;MAGA,IAAIT,OAAJ,EAAa;QACX,KAAKD,UAAL,CAAgBC,OAAhB;MACF;;MAIA,IAAI,CAAC,KAAKA,OAAL,CAAawD,OAAlB,EAA2B;QACzB,IAAMzB,WAAW,KAAK9B,SAAL,CAAesC,IAAf,CAAoB,UAACC,CAAD;UAAA,OAAOA,EAAExC,OAAF,CAAUwD,OAAjB;QAAA,CAApB,CAAjB;;QACA,IAAIzB,QAAJ,EAAc;UACZ,KAAKhC,UAAL,CAAgBgC,SAAS/B,OAAzB;QACF;MACF;;MAEA,IAAIyD,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACzC,IAAI,CAACC,MAAMC,OAAN,CAAc,KAAK7D,OAAL,CAAaG,QAA3B,CAAL,EAA2C;UACzC2D,QAAQC,KAAR;QAGF;MACF;;MAEA,IAAMC,kBAAkB,IAAIC,eAAJ,EAAxB;;MAKA,IAAMC,oBAAoB,SAApBA,iBAAoB,CAACC,MAAD,EAAqB;QAC7CC,OAAOC,cAAP,CAAsBF,MAAtB,EAA8B,QAA9B,EAAwC;UACtCG,YAAY,IAD0B;UAEtCC,KAAK,eAAM;YACT,oDAA4B,IAA5B;;YACA,OAAOP,gBAAgBQ,MAAvB;UACF;QALsC,CAAxC;MAOF,CARA;;MAWA,IAAMC,UAAU,SAAVA,OAAU,GAAM;QACpB,IAAMjB,UAAUtE,cAAc,OAAKc,OAAnB,EAA4BsD,YAA5B,CAAhB;QAGA,IAAMoB,iBAGF;UACFvE,UAAU,OAAKA,QADb;UAEFK,MAAM,OAAKA;QAFT,CAHJ;QAQA0D,kBAAkBQ,cAAlB;;QAEA,oDAA4B,KAA5B;;QACA,IAAI,OAAK1E,OAAL,CAAa2E,SAAjB,EAA4B;UAC1B,OAAO,OAAK3E,OAAL,CAAa2E,SAAb,CACLnB,OADK,EAELkB,cAFK,EAGL,MAHK,CAAP;QAKF;;QAEA,OAAOlB,QAAQkB,cAAR,CAAP;MACF,CAxBA;;MA2BA,IAAME,UAGF;QACFtB,0BADE;QAEFtD,SAAS,KAAKA,OAFZ;QAGFG,UAAU,KAAKA,QAHb;QAIFG,OAAO,KAAKA,KAJV;QAKFmE;MALE,CAHJ;MAWAP,kBAAkBU,OAAlB;MAEA,8BAAK5E,OAAL,CAAa6E,QAAb,gFAAuBC,OAAvB,CACEF,OADF,EAEE,IAFF;;MAMA,0CAAoB,KAAKtE,KAAzB;;MAGA,IACE,KAAKA,KAAL,CAAWO,WAAX,KAA2B,MAA3B,IACA,KAAKP,KAAL,CAAWyE,SAAX,+BAAyBH,QAAQtB,YAAjC,0DAAyB,sBAAsB9C,IAA/C,CAFF,EAGE;QAAA;;QACA,+DAAe;UAAES,MAAM,OAAR;UAAiBT,gCAAMoE,QAAQtB,YAAd,2DAAM,uBAAsB9C;QAA7C,CAAf;MACF;;MAEA,IAAMwE,UAAU,SAAVA,OAAU,CAACjB,KAAD,EAA0C;QAExD,IAAI,EAAErE,iBAAiBqE,KAAjB,KAA2BA,MAAMpC,MAAnC,CAAJ,EAAgD;UAC9C,mEAAe;YACbV,MAAM,OADO;YAEb8C;UAFa,CAAf;QAIF;;QAEA,IAAI,CAACrE,iBAAiBqE,KAAjB,CAAL,EAA8B;UAAA;;UAE5B,0FAAYlE,MAAZ,EAAmBmF,OAAnB,+GACEjB,KADF,EAEE,MAFF;UAIA,2FAAYlE,MAAZ,EAAmBoF,SAAnB,gHACE,OAAK3E,KAAL,CAAWU,IADb,EAEE+C,KAFF,EAGE,MAHF;QAKF;;QAEA,IAAI,CAAC,OAAKmB,oBAAV,EAAgC;UAE9B,OAAK3E,UAAL;QACF;;QACA,OAAK2E,oBAAL,GAA4B,KAA5B;MACF,CA3BA;;MA8BA,sCAAgBzF,cAAc;QAC5B0F,gBAAgB7B,YAAhB,aAAgBA,YAAhB,uBAAgBA,aAAc6B,cADF;QAI5BC,IAAIR,QAAQH,OAJgB;QAK5BY,OAAOrB,gBAAgBqB,KAAhB,CAAsBC,IAAtB,CAA2BtB,eAA3B,CALqB;QAM5BuB,WAAW,mBAACvE,IAAD,EAAU;UAAA;;UACnB,IAAIA,SAAS,MAAb,EAAwB;YACtB,IAAIyC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;cACzCG,QAAQC,KAAR,iJAC2I,OAAK3D,SADhJ;YAGF;;YACA4E,QAAQ,IAAIQ,KAAJ,WAAa,OAAKpF,SAAlB,wBAAR;YACA;UACF;;UAEA,IAAI;YACF,OAAKqF,OAAL,CAAazE,IAAb;UACF,CAFA,CAEA,OAAS+C,KAAT,EAAgB;YACdiB,QAAQjB,KAAR;YACA;UACF;;UAGA,4FAAYlE,MAAZ,EAAmB0F,SAAnB,kHAA+BvE,IAA/B,EAAqC,MAArC;UACA,4FAAYnB,MAAZ,EAAmBoF,SAAnB,kHACEjE,IADF,EAEE,OAAKV,KAAL,CAAWyD,KAFb,EAGE,MAHF;;UAMA,IAAI,CAAC,OAAKmB,oBAAV,EAAgC;YAE9B,OAAK3E,UAAL;UACF;;UACA,OAAK2E,oBAAL,GAA4B,KAA5B;QACF,CArC4B;QAsC5BF,gBAtC4B;QAuC5BU,QAAQ,gBAACC,YAAD,EAAe5B,KAAf,EAAyB;UAC/B,mEAAe;YAAE9C,MAAM,QAAR;YAAkB0E,0BAAlB;YAAgC5B;UAAhC,CAAf;QACF,CAzC4B;QA0C5B6B,SAAS,mBAAM;UACb,mEAAe;YAAE3E,MAAM;UAAR,CAAf;QACF,CA5C4B;QA6C5B4E,YAAY,sBAAM;UAChB,mEAAe;YAAE5E,MAAM;UAAR,CAAf;QACF,CA/C4B;QAgD5B6E,OAAOlB,QAAQ5E,OAAR,CAAgB8F,KAhDK;QAiD5BC,YAAYnB,QAAQ5E,OAAR,CAAgB+F,UAjDA;QAkD5BC,aAAapB,QAAQ5E,OAAR,CAAgBgG,WAlDD;QAmD5BC,QAAQ;UAAA,OAAM,IAAN;QAAA;MAnDoB,CAAd,CAAhB;;MAsDA,OAAO,sCAAcC,KAAd,EAAP;IACF;EAjYW;;EAAA;AAAA,EAKHvG,SALG,EAAN;;oBAmYKwG,M,EAAqC;EAAA;;EAC7C,IAAMC,UAAU,SAAVA,OAAU,CACd9F,KADc,EAEgB;IAAA;;IAC9B,QAAQ6F,OAAOlF,IAAf;MACE,KAAK,QAAL;QACE,uCACKX,KADL;UAEE+F,mBAAmBF,OAAOR,YAF5B;UAGEW,oBAAoBH,OAAOpC;QAH7B;;MAKF,KAAK,OAAL;QACE,uCACKzD,KADL;UAEEO,aAAa;QAFf;;MAIF,KAAK,UAAL;QACE,uCACKP,KADL;UAEEO,aAAa;QAFf;;MAIF,KAAK,OAAL;QACE,qDACKP,KADL,GAEKiG,WAAWjG,MAAMU,IAAjB,EAAuB,OAAKhB,OAA5B,CAFL;UAGE+E,2BAAWoB,OAAO3F,IAAlB,uDAA0B;QAH5B;;MAKF,KAAK,SAAL;QACE,uCACKF,KADL;UAEEU,MAAMmF,OAAOnF,IAFf;UAGEwF,iBAAiBlG,MAAMkG,eAAN,GAAwB,CAH3C;UAIEtF,wCAAeiF,OAAOjF,aAAtB,yEAAuCuF,KAAKC,GAAL,EAJzC;UAKE3C,OAAO,IALT;UAME5B,eAAe,KANjB;UAOEwE,QAAQ;QAPV,GAQM,CAACR,OAAO/E,MAAR,IAAkB;UACpBP,aAAa,MADO;UAEpBwF,mBAAmB,CAFC;UAGpBC,oBAAoB;QAHA,CARxB;;MAcF,KAAK,OAAL;QACE,IAAMvC,QAAQoC,OAAOpC,KAArB;;QAEA,IAAIrE,iBAAiBqE,KAAjB,KAA2BA,MAAMX,MAAjC,0BAA2C,MAA3C,eAAJ,EAAkE;UAChE,6DAAY,MAAZ;YAA+BvC,aAAa;UAA5C;QACF;;QAEA,uCACKP,KADL;UAEEyD,YAFF;UAGE6C,kBAAkBtG,MAAMsG,gBAAN,GAAyB,CAH7C;UAIEC,gBAAgBJ,KAAKC,GAAL,EAJlB;UAKEL,mBAAmB/F,MAAM+F,iBAAN,GAA0B,CAL/C;UAMEC,oBAAoBvC,KANtB;UAOElD,aAAa,MAPf;UAQE8F,QAAQ;QARV;;MAUF,KAAK,YAAL;QACE,uCACKrG,KADL;UAEE6B,eAAe;QAFjB;;MAIF,KAAK,UAAL;QACE,uCACK7B,KADL,GAEK6F,OAAO7F,KAFZ;IA7DJ;EAkEF,CArEA;;EAuEA,KAAKA,KAAL,GAAa8F,QAAQ,KAAK9F,KAAb,CAAb;EAEAf,cAAcuH,KAAd,CAAoB,YAAM;IACxB,OAAK7G,SAAL,CAAe8G,OAAf,CAAuB,UAAChF,QAAD,EAAc;MACnCA,SAASiF,aAAT;IACD,CAFD;;IAIA,sCAAY/D,MAAZ,CAAmB;MAAEC,OAAO,MAAT;MAAejC,MAAM,SAArB;MAAgCkF;IAAhC,CAAnB;EACD,CAND;AAOF;;AAGK,SAASI,UAAT,CAMLvF,IANK,EAOLhB,OAPK,EAQL;EACA;IACEqG,mBAAmB,CADrB;IAEEC,oBAAoB,IAFtB;IAGEzF,aAAarB,SAASQ,QAAQgG,WAAjB,IAAgC,UAAhC,GAA6C;EAH5D,GAIMhF,SAAS,MAAT,IACD;IACC+C,OAAO,IADR;IAEC4C,QAAQ;EAFT,CALL;AAUF;;AAEA,SAAStG,eAAT,CAMEL,OANF,EAO6B;EAC3B,IAAMgB,OACJ,OAAOhB,QAAQiH,WAAf,KAA+B,UAA/B,GACKjH,QAAQiH,WAAR,EADL,GAEIjH,QAAQiH,WAHd;EAKA,IAAMC,UAAUlG,SAAS,MAAzB;EAEA,IAAMmG,uBAAuBD,UACzB,OAAOlH,QAAQmH,oBAAf,KAAwC,UAAxC,GACGnH,QAAQmH,oBAAR,EADH,GAEEnH,QAAQmH,oBAHe,GAIzB,CAJJ;EAMA,OAAO;IACLnG,UADK;IAELwF,iBAAiB,CAFZ;IAGLtF,eAAegG,UAAWC,oBAAX,aAAWA,oBAAX,cAAWA,oBAAX,GAAmCV,KAAKC,GAAL,EAAnC,GAAiD,CAH3D;IAIL3C,OAAO,IAJF;IAKL6C,kBAAkB,CALb;IAMLC,gBAAgB,CANX;IAOLR,mBAAmB,CAPd;IAQLC,oBAAoB,IARf;IASLvB,WAAW,IATN;IAUL5C,eAAe,KAVV;IAWLwE,QAAQO,UAAU,SAAV,GAAsB,SAXzB;IAYLrG,aAAa;EAZR,CAAP;AAcF","names":["ensureQueryFn","noop","replaceData","resolveEnabled","timeUntilStale","notifyManager","canFetch","createRetryer","isCancelledError","Removable","Query","config","defaultOptions","setOptions","options","observers","cache","queryKey","queryHash","getDefaultState","state","scheduleGc","meta","promise","updateGcTime","gcTime","length","fetchStatus","remove","newData","data","type","dataUpdatedAt","updatedAt","manual","setStateOptions","cancel","then","catch","Promise","resolve","silent","destroy","setState","some","observer","enabled","getObserversCount","isActive","isInvalidated","getCurrentResult","isStale","staleTime","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","shouldFetchOnReconnect","includes","push","clearGcTimeout","notify","query","filter","revert","cancelRetry","fetchOptions","continueRetry","queryFn","process","env","NODE_ENV","Array","isArray","console","error","abortController","AbortController","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","queryFnContext","persister","context","behavior","onFetch","fetchMeta","onError","onSettled","isFetchingOptimistic","initialPromise","fn","abort","bind","onSuccess","Error","setData","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","start","action","reducer","fetchFailureCount","fetchFailureReason","fetchState","dataUpdateCount","Date","now","status","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["/Users/andrew/node_modules/@tanstack/query-core/src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.data === undefined ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const queryFnContext: OmitKeyof<\n        QueryFunctionContext<TQueryKey>,\n        'signal'\n      > = {\n        queryKey: this.queryKey,\n        meta: this.meta,\n      }\n\n      addSignalProperty(queryFnContext)\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn as QueryFunction<any>,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext as QueryFunctionContext<TQueryKey>)\n    }\n\n    // Trigger behavior hook\n    const context: OmitKeyof<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"]},"metadata":{},"sourceType":"module"}